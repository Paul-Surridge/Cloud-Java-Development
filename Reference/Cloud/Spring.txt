Spring Framework:

	Overview:

		- Spring Framework written in java and actively maintained by Spring.
		- Spring Framework broadly involves:

			1. Beans - Definition:		Define beans to be available within container via:												[Compile Time Checking]

								1. *.xml file:					Contain bean definitions within an external *.xml file.					-
								2. Java Source Code - Annotations:		Contain bean definitions within the java source code, identified using annotations.	Y

			2. Container:			Instantiate Spring IoC container and register all bean definitions in the java source code.

			3. Beans - Instantiation:	Instantiate beans within container as instantiated within the source code during runtime:

								1. *.xml file:					Reference bean definitions in external *.xml file.
								2. Java Source Code - Annotations:		Reference bean definitions registered by Spring via annotations.

	Container:

		- Container is a Spring IoC 'Inversion of Control' container:

			1. Beans:			Beans are housed within the container.
			2. Bean Management:		Bean lifecycles are managed by the container.

		- Container is represented and accessible via the ApplicationContext interface.

	Metadata:						

		- Spring Framework makes extensive use of metadata on how to build and manage the container and its contents.
		- Spring Framework metadata is contained within either *.xml or annotations:

			XML (*.xml file):

				Pros:

					- XML encourages separation of concerns.
					- XML is kept external to the source code.
					- XML is relatively limited in size and easily viewed.
					- XML does not require recompilation upon modification.
					- XML requires the least amount of text/files to changed upon modification.
					- XML is more centralised.
					- XML is more verbose and may be preferable in providing clarity for beginners. 

				Cons:

					- XML is error prone, typos are difficult to spot and debug (even though there are many tools available to validate *.xml files).
					- XML may lead to runtime errors:

						1. Java Source Code:	Java source code is modified where an additional argument is added to a beans constructor.
						2. XML:			*.xml file is not updated with this additional argument.
						3. Runtime Error:	Program will run and this issue will not be noticed until the bean is instantiated during runtime.

					- XML is not type-safe i.e. no compiler will check the manually typed types passed during dependency injection.
					- XML can lead to ill-fitting awkward constructs which are more simple to be implemented within java source code.

			Annotations:

				Pros:

					- Annotations tend to lead to shorter more concise configuration overall.
					- Annotations allows for dependency injection to be alot closer to the source code rather than being kept in separate *.xml file(s).
					- Annotations ensure type-safety.
					- Annotations are checked at compile time.
					- Annotations self-document the source code providing more immediate clarity on what is being injected by Spring rather than having to refer to a separate *.xml file.

				Cons:

					- Annotations reside within and clutter source code.
					- Annotations are more decentralised leading to configuration metadata being spread throughtout the codebase, leading to an overall lack of centralised oversight and control of the configuration.
					- Annotations require recompilation of source code upon modification.
					- Annotations maybe considered less intuitive due their brevity in particular for students of Spring.

			Summary:

				- No Ideal:		No ideal approach, generally a combination of both *.xml and annotations are deployed.
				- Project:		Project requirements generally determine the ideal approach e.g. using the conventions already within an existing project.
				- Industry:		Industry trend is generally to use annotations over *.xml.
				- Synchronous:		Synchronous behaviour and outcome can be achieved using either *.xml or annotations i.e. a table of equivalent/matching XML elements and annotations.
				- @Component:		@Component annotation goes some way in providing the best of both *.xml and annotations.

	Bean:

		Overview:

			- Bean is an instantiation assembled, managed and housed within a container, bean may be either:

				1. Primitive
				2. Object (POJO)

			- Bean is not a wrapper object that encloses another java object.
			- Bean is the generic name given to all primitives/objects which are declared as beans and available to be injected/assigned to variables within the source code within the container.
			- Bean is given a default ID if one not explicitly defined within the metadata.
			- Bean can cause a graph of beans to be instantiated as a bean may include other types of beans.

		Bean Declaration/Definition:

			- Bean is declared and defined via x3 methods:

				1. *.xml
				2. @Bean
				3. @Component

			- Bean is declared and defined as follows:

				1. *.xml:		Declare and define beans within a separate *.xml file (e.g. beans.xml).

								<bean class="<package1.package2.class1>">				//Declare a bean of class1
								<bean id="<bean_id>" class="<package1.package2.class2>">		//Declare a bean of <bean_id> of class2
								<bean id="<bean_id>" class="<package1.package2.class3>">		//Declare a bean of <bean_name> of class3
								    <property name=<bean_name> ref=<bean_reference>>
								</bean>

				2. Annotations:		Declare and define beans by using annotations directly within the source code.

								1. @Bean (Bean Methods):

									- Bean methods 'produce', 'generate' and return object/primitive beans.
									- Bean methods are invoked to instantiate and return a bean which are injected into variables.
									- Bean methods are registered by Spring when a container is instantiated.
									- Bean methods are typically collated into a single location e.g. a configuration class.
									- Bean methods are useful when additional initialisation needs to be applied to a bean before it is injected.

									Object:

										@Bean						//Bean Method returns an object as a bean
										public ClassA methodName() {
									    	    return new ClassA();
										}

										@Bean						//Bean Method returns an object which implements an interface as a bean
										public InterfaceA methodName() {
									    	    return new InterfaceAImpl();
										}

									Primitive:

										@Bean						//Bean Method returns a primitive as a bean
										public int returnField() {
									    	    return ifield;
										}

								2. @Component:

									- @Component is an annotation which declares the annotated entity as a component which is automatically registered by Spring within a @ComponentScan:

										@Component					//Class declared a bean/component of the container
										public class className
										{...}

							Configuration Classes:

								- Configuration classes are collations of @Bean i.e. dedicated classes which contain all of the bean declarations used throughout the container.
								- Configuration classes can be imported into other configuration classes via the @import annotation known as 'Modularising Configuration':

									@Import(ConfigurationClass1.class)
									public class ConfigurationClass2
									{...}

		Bean Callback Methods:

			- Bean callback methods are the methods which are 'called back' upon a particular external event e.g. click, mousemove, initialise, destroy...
			- Bean callback methods can be declared within:

				1. *.xml file:

					1. Beans element attribute:	<beans default-init-method="<initialisation_method>"				Bad practice: This is inappropriate given that is applied to all beans.
					2. Bean element attribute:	<bean id="..." init-method="<specific_initialisation_method>"			Bad practice: This is prone to error due to need for excessive maintenance.

				2. Annotations:

					- Annotations are considered the best practice for implementing callback methods within a modern Java spring application.
					- Annotations prevent callback names from being coupled to Spring specific interfaces.
					- Annotation based callback methods include:

						@PostConstruct					//Run the method upon the event of the bean initialisation.
					    	public void initMethod() {
					       	    log.info("Initialise all aspects of the bean as if a constructor");
					    	}

						@PreDestroy					//Run the method upon the event of the bean garbage collection.
					    	public void destroyMethod(){
					            log.info("Destroy all aspects of the bean as if a destructor");
					    	}

						NB: Annotations library needs to be included within the project.

		Events:

			- ApplicationContext implements interface ApplicationEventPublisher which encapsulates event publication functionality.
			- ApplicationContext is therefore able to handle events via the use of the following entities:

				1. Class:		ApplicationEvent
				2. Interface:		ApplicationListner

				Bean implements ApplicationListner and will receive ApplicationEvents published to the ApplicationContext (standard Observer design pattern).

			- Application events can be listened via x2 ways:

				1. Interface: ApplicationListener

					1. Bean implement ApplicationListener.

						- Bean will now have the necessary interface to enable the container ApplicationContext to pass in events which a bean instantiation can listen for.

					2. Bean override:

						@Override
    						public void onApplicationEvent(ContextRefreshedEvent event) {
        					    log.info("Container ready for use.");
    						}

					3. Bean will receive events depending upon the particular event specified in the parameter.

 						- onApplicationEvent() is an overloaded method.
						- Parameter determines which event type will be listened to and returned e.g. in this case a ContextRefreshedEvent.

				2. Annotation: @EventListner

					- Annotations can be added to methods to enable them to receive event notifications:

						@EventListner
    						public void onRenamedApplicationEvent(ContextRefreshedEvent event) {
        					    log.info("Container ready for use.");
    						}

					- Annotations enable the method to be called other more appropriate names other than onApplicationEvent().
					- Annotations allow the parameter to specify the type of event that is listened for by this particular listner method.

						@EventListner(ContextRefreshedEvent.class)
    						public void onRenamedApplicationEvent() {
        					    log.info("Container ready for use.");
    						}

						NB: Annotations with only x1 element named 'value' can omit the 'value =' when the annotation is deployed.

							@EventListner(value = ContextRefreshedEvent.class)
							@EventListner(ContextRefreshedEvent.class)

					- Annotation is passed the type of event to listen for compared to an overriden onApplicationEvent() and having to include a parameter that may not necessarily be used within the body of the method.
					- Annotation can be expanded to listen for multiple events (presumably by passing multiple events into the annotation).

	Dependencies:

		Overview:

			- Dependencies are entities that are used or depended upon by other entities to operate and implement their own required functionality.
			- Dependencies and the term 'dependency' as follows:

				1. Source Code:		The term 'dependency' ultimately refers to the entities at source code level:

								ClassA may contain instances of ClassB:						ClassA depends on ClassB
								ClassA may contain instances of ClassC which uses InterfaceD:			ClassA depends on ClassC and InterfaceD

				2. Application Level:	The term 'dependency' may refer to any file, resource, library or program (3rd party or otherwise) that the source code within an application uses and depends upon.

								e.g. a Build Tool maybe said to 'have its own dependencies' but those dependencies will ultimately be collections of source code entities used by that Build Tool i.e. the Build Tool is itself ultimately just a program.
			
			- Dependencies may be collated, organised and contained within:

				Libraries
				Frameworks
				...

			- Dependencies at the application level are typically downloaded, cached and managed by a Build Tool e.g. Maven from mvnrepository.com
			- Dependencies are said to be transitive if:

				Example 1:

					ClassB depends on ClassC
					ClassA depends on ClassB

					ClassA depends on ClassB and transitively on ClassC.

				Example 2:

					Module 1 declares a dependency of Framework 1
					Module 2 declares a dependency of Framework 2

					Module 1 declares a dependency of Module 2
					Module 1 now has access to both Framework 1 and transitively Framework 2

		Dependency Injection:

			- Dependency injection is injecting a bean which exists within the container into a variable within another bean within the container:

				Container____________________________________________________
				|							     |
				|    Class A (Bean A)___	Class B (Bean B)________     |		Bean A:		Dependent Bean (Target/Receiving Bean)
				|    |			|	|			|    |		Bean B:		Depedency Bean (Injected Bean)
				|    | new Class B <------------|			|    |
				|    | 			|	|			|    |
				|    | 			|	|			|    |
				|    | 			|	|			|    |
				|    |__________________|	|_______________________|    |    				
				|____________________________________________________________|				

			- Dependency injection can be implemented via x3 forms:

				DI Form			Description										XML Element
				__________________________________________________________________________________________________________________________________________________________________________

				1. Constructor Based:	The dependency bean (Bean B) is injected to Bean A via the constructor of Bean A.	<constructor-arg ref="<bean_id>"/>
				2. Setter Based:	The dependency bean (Bean B) is passed to Bean A via a setter method of Bean A.		<property name="<name_of_field_in_bean>" ref="<bean_id>"/>
				3. Field Based:		The dependency bean (Bean B) is directly injected into Bean A.

				NB: Spring will convert a string passed within the attribute of an XML element to all primitive types that corresponds with the injected variable type within the bean. 

				Constructor Based DI:

					- Constructor based DI is the most recommended form of DI in particular for mandatory dependencies.
					- Constructor based DI enables:

						1. Immutable Objects:		Enables the creation of application components as immutable objects and then not providing any further 'setter' methods for those fields.
						2. Not Null:			Enables the assurance that dependencies are not null within the dependent bean.
						3. Fully Initialised:		Enables the assurance that beans are fully initialised when instaniated.

					- Constructor arguments should be limited to at most x3, a large number implies the class has too many responsibilities, should be refactored to better address proper separation of concerns.

						class ClassA
						{
						    ClassB bBean;

						    @Autowired
						    ClassA(ClassB bBean)
						    {
							this.bBean = bBean;
						    }
							
						    ClassA(@Autowired ClassB bBean)
						    {
							this.bBean = bBean;
						    }
						}

				Setter Based DI:

					- Setter based DI recommended for optional dependencies.
					- Setter based DI should only be used for optional dependencies that can be assigned reasonable default values within the dependent class, otherwise continual not-null checks are needed wherever that dependent class is used.
					- Setter based DI enables objects to be reconfigured or re-injected at future point in time.
					- Setter based DI enables the ability to prevent circular dependencies from occuring.

						class ClassA
						{
						    ClassB bBean = [Default Value];

						    @Autowired
						    void setBean(ClassB bBean)
						    {
							this.bBean = bBean;
						    }
							
						    void setBean(@Autowired ClassB bBean)
						    {
							this.bBean = bBean;
						    }
						}

				Field Based DI:

					- Field based DI involves injecting bean directly into variable as they are initialised:

						class ClassA
						{
						    @Autowired
						    ClassB bBeanB;

						    @Autowired
						    ClassC bBeanC;
						}

			- Dependency injection most appropriate form typically depends on the requirements of the class/project.
			- Dependency injection is typically pre-decided within 3rd party classes e.g. they do not supply a setter method therefore only constructor DI available.

		Circular Dependencies:

			- Circular dependencies can arise through constructor based DI.

				- ClassA		Requires and instance of ClassB via constructor DI.
				- ClassB		Requires and instance of ClassA via constructor DI.

			- Circular dependencies will occur if ClassA is injected into ClassB and vice versa, at which point Spring container detects this circular reference at runtime and throws BeanCurrentlyInCreationException.
			- Circular dependencies can be implemented successfully by using Setter DI on x1 or both classes (even though Setter DI is in general not recommended).
 
	Annotations:

		- Annotations are metadata and form markers read by the Spring Container.
		- Annotations are read and processed using Reflection.
		- Annotations are case sensitive.

			@Component != @component

		- Annotations instruct the container to perform some action with the annotated entity.
		- Annotations have many types:

			Stereotype Annotation:

				- Stereotype annotations conform to a fixed or general pattern.
				- Stereotype annotations include:

					@Component			Generic stereotype for any Spring-managed component
						@Service		Applied to Service classes				Layer - Service
						@Controller		Applied to Controller classes				Layer - Presentation
						@Repository		Applied to Storage classes 				Layer - Persistence
						@Configuration		Applied to Configuration classes			Layer - Configuration

					NB:
						- @Service, @Controller, @Repository are all specialisations of @Component and are all themselves annotated by the @Component annotation, therefore all will be considered components when scanned by Spring via @ComponentScan.
						- Annotations compound similar to extended classes/interfaces where extensions naturally contain all of the traits of the class being extended. 

				- Stereotype annotations are markers for any entity that fulfills the annotations particularly described role within an application.

		- Annotations 'CommonAnnotationBeanPostProcessor':

			- Annotations library and annotations processor needs to be explicitly specified for annotations to be accessible and processed by Spring.
			- Annotations library and annotations processor is included in a project as follows:

				1. *.xml:		Add bean:		<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>

											- CommonAnnotationBeanPostProcessor is a class used to process annotations to be used within the bean.
											- CommonAnnotationBeanPostProcessor is used when not using @Autowired, when @Autowired is used the below equivalent processor is instantiated:

												org.springframework.context.annotation.InternalCommonAnnotationProcessor

				2. Project POM:		Add dependency:		Javax Annotation API (as found on mvn repository).
				3. Module POM:		Add dependency:		Javax Annotation API (via refering to the dependency in Project POM).

			- Annotations can now be used within the project to interact with the enclosing container.

		- Annotations are applied to the immediate statement below the annotation (not all stacked statements):

			@Autowired
			int iMaxNumber;			//@Autowired only applied to iMaxNumber
			int iMinNumber;
			
			@Autowired
			int iMaxNumber;			//@Autowired applied to both iMaxNumber and iMinNumber
			@Autowired
			int iMinNumber;

			@Autowired
			int iMinNumber, iMaxNumber;	//@Autowired applied to both iMaxNumber and iMinNumber

		- Annotations:

			@Autowired:

				- @Autowired can be applied to:

					1. Fields
					2. Parameters
					3. Setter Methods

				- @Autowired automatically wires i.e. automatically invokes, obtains and injects beans into fields, parameters or setter methods within other beans, upon encountering @Autowired:

					1. Search:	Spring searches all x3 forms of bean generation within local container.

								Bean Generation
								_________________________________

								1. *.xml file
								2. @Bean 	(Bean Method)
								3. @Component	(Component Entity)

					2. Find:	Spring finds a bean generator where the following aspects require to match:

								Bean Generator			Variable		Object [Match Required]		Primitive [Match Required]
								_____________________________________________________________________________________________________________

								1. Type				Type			Y				Y
								2. Bean Method Name		Name			-				Y

					3. Inject:	Spring invokes the bean generator and injects an instance of the matching bean into the @Autowired variable.

				- @Autowired is enabled in the project via following sequence:

					*.xml file:

						1. Namespace:		Add the context namespace:		xmlns:context="http://www.springframework.org/schema/context"
						2. Tag:			Add the tag:				<context:annotation-config>					//annotation-config belongs to the context namespace
						3. Schema:		Add the schema:				http://www.springframework.org/schema/context
														http://www.springframework.org/schema/context/spring-context.xsd
					Java Source Code:

						4. Add @Autowired	@Autowired can now be used within the source code.

				- @Autowired can only be used within a bean i.e. the enclosing entity needs to be annotated @Component or be declared as a bean (by other means).
				- @Autowired uses an instance of the org.springframework.context.annotation.internalCommonAnnotationProcessor.
				- @Autowired is recommended to be used with the following priority:

					Priority		@Autowired Use
					______________________________________

					1st			Constructor
					2nd			Field

				- @Autowired Examples:

					1. Fields:

						@Autowired      				//Spring will inject the bean 'NumberGenerator'
    						private NumberGenerator numberGenerator;	//Spring does not require 'new' keyword, the instantiation is handled by container

						@Autowired
						private InterfaceA interface;			//Spring will inject the bean which implements this interface (there must be only x1 class in the container which implements this interface).


						@Bean
						public int iMaxNumber() {
					    	    return 100;
						}

						@Autowired
    						private int iMaxNumber;				//Spring will inject value to the primitive iMaxNumber, name and type must match

					2. Constructors:

						- @Autowired is applied to the ClassB objClassB where ClassB has been declared a bean:

							@Autowired
							ClassA (ClassB objClassB)
							{...}

							Or

							ClassA (@Autowired ClassB objClassB)
							{...}

						- @Autowired can use qualifiers @MinNumber @MaxNumber which perform more specific injection as defined within the custom annotation which utilises @Qualifier.

							@Autowired
    							public NumberGeneratorImpl(@MaxNumber int maxNumber, @MinNumber int minNumber) {
        							this.maxNumber = maxNumber;
        							this.minNumber = minNumber;
    							}

					3. Setter Methods:

						@Autowired
						void setterMethod (ClassB objClassB)
						{...}

						Or

						void setterMethod (@Autowired ClassB objClassB)
						{...}

			@Bean:
			@Bean("<bean_name>"):

				- @Bean declares that the annotated method is a Bean Method.
				- @Bean will instantiate, configure and return a bean.
				- @Bean("<bean_name>") will override the default name of the bean (which is the name of the method):

					Annotation			Bean Name
					________________________________________________

					@Bean:				Bean Method Name
					@Bean("<bean_name>"):		<bean_name>

				- @Bean("<bean_name>") should be avoided given that it requires additional hardcoding of names which maybe prone to error and necessary to be maintained.
				- @Bean can be refined using @Qualifier.
				- @Bean examples:

					1. Objects:

						@Bean
						public InterfaceA methodName() {
						    return new InterfaceAImpl();
						}

						@Bean
						public ClassA classA() {
						    return new ClassA();
						}

					2. Primitives:

						@Bean
						public int primitiveName() {
						    return 10;
						}

			@Component:
			@Component("<component_name>"):				
			
				- @Component declares the annotated entity to be a component (or bean) within the container:
				- @Component("<component_name>") overrides the default name of the bean which is the name of the entity being annotated:

					Annotation				Bean Name
					________________________________________________________

					@Component:				Entity Name
					@Component("<component_name>"):		<component_name>

				- @Component is scanned and registered as a bean via @ComponentScan.
				- @Component should ideally only be declared against classes not interfaces given:

					1. Interfaces should always be de-coupled from the implementation.
					2. Interfaces should not depend on spring.

					Designating an interface a component will couple and make that interface dependent on spring.

				- @Component examples:

					@Component
					public class className
					{...}

					NB: It is presumed that @Component can be applied to anything that can be used as a bean e.g.

						1. Top Level Forms:	Class, interface Abstract Class, Enum
						2. Primitives

			@ComponentScan:
			@ComponentScan(basePackages="<root_package>"):

				- @ComponentScan scans all *.java files within the project looking for @Component annotations:
				- @ComponentScan scans all *.java files within the base package and all sub-packages:

					Annotation						Base Package
					__________________________________________________________________________________________________________________________

					@ComponentScan:						The package that the entity annotated with @ComponentScan resides.
					@ComponentScan(basePackages="<base_package>")		The package specified as <base-package>.

				- @ComponentScan will find all 'candidates' that can be scaned e.g. @Configuration is a candidate to be scanned given that @Configuration itself is annotated with @Component.
				- @ComponentScan operates as expected when included within a transitive Configuration Class:

					1. Project contains x2 modules with the same folder structure:

						Module 1:	src/main/java/org/application
						Module 2:	src/main/java/org/application

					2. Module 1:	Configuration class contains @ComponentScan(base package = 'org.application').
					3. Module 2:	Configuration class @Import the Configuration Class from module 1 as a transitive dependency.
					4. Component scanning will be applied to the same location 'application/' in both modules (given that both modules share the same Configuration Class).

				- @ComponentScan can be placed within any file located within the base package that will form the root of the scan.

			@Configuration:

				- @Configuration declares the annotated class a configuration class.
				- @Configuration classes typically contain all of the Bean Methods used within the container.
				- @Configuration examples:

					@Configuration
					public class AppConfig {
    					    @Bean
					    //Bean Method 1
    					    @Bean
					    //Bean Method 2
    					    @Bean
					    //Bean Method 3
					}

			@EnableWebMvc:

				- @EnableWebMvc is used with the configuration classes to import the Spring MVC configuration.
				- @EnableWebMvc will by default register beans which are specific to Spring MVC e.g. ViewResolver, QuestMappers etc...

			@Import(OtherConfgurationClass.class):

				- @Import(ConfgurationClass.class) is for importing a configration class into another configuration class as a transitive dependency.
				- @Import(ConfgurationClass.class) effectively 'concatenates' both configuration classes.
				- @Import(ConfgurationClass.class) example:

					@Import(OtherConfiguration.class)
					@Configuration
					public class Configuration {
    					    @Bean
					    //Bean Method 1
    					    @Bean
					    //Bean Method 2
    					    @Bean
					    //Bean Method 3
					}
		
			@PostConstruct:

				- @PostConstruct declares the annotated method a 'callback method' to be invoked once the bean has been instantiated and initialised.
				- @PostConstruct example:

					@PostConstruct
					public void init() {
        				   //Initialisation of bean
    					}

			@PreDestroy:

				- @PreDestroy declares the annotated method a 'callback method' to be invoked once the bean has been destroyed.
				- @PreDestroy example:

					@PreDestroy
					public void deallocateResources() {
        				   //Deallocate all resources of the bean
    					}

			@Primary:

				- @Primary is an effective way to autowire several instances where one primary candidate can be determined.

			@PropertySource(<path_to_properties_file>")

				- @PropertySource enables the inclusion of a properties file within the configuration class.
				- @PropertySource example:

					@Configuration
					@PropertySource("classpath:config/game.properties")		//NB: @PropertySource("file:...") if the properties file is not on the classpath
					public class GameConfig {...}

				- @PropertySource presumes a project directory structure and corresponding classpath of:

					classpath = moduleName/src/main/resources

			@Qualifier:

				- @Qualifier is used to refine the selection of which bean should be injected within an @Autowired.
				- @Qualifier is used to build a custom annotation which can be applied to a @Bean method to uniquely identify and request that particular bean be injected within an @Autowired (rather than let Spring make its best guess).

					- Qualifiers are custom annotations.	
					- Qualifiers are created and used as follows:

						1. Build Custom Annotation:

							- Apply annotations to the custom annotation:

								@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})		//Annotation MaxNumber can be assigned to Fields, Parameters and Methods only
								@Retention(RetentionPolicy.RUNTIME)						//Annotation MaxNumber is retained throughout runtime (by the JVM)
								@Qualifier
								public @interface MaxNumber {

								}

						2. Bean Methods:

							- Apply custom annotation to the respective Bean Method:

								@MaxNumber
								@Bean
								public int MaximumNumber(){
						    		    return 100;
								}

						3. Bean Injection:

							- Apply custom annotation to the fields/parameter/method to be injected with the return of the Bean Method:

								@MaxNumber
								private int iLargestNumber;

							- Bean will now be injected using the bean method annotated and associated with @MaxNumber.

						4. Flexibility:

							- Qualifier is now the 'link' or means in which Spring uses to identify which bean to inject.
							- Qualifier no longer requires:

								Bean Method Name = Injected Field Name

			@Service:

				- @Service is a stereotype annotation for the Service layer.
				- @Service is used by @Controller(s) to process, calculate and return data.
				- @Service is an extension of @Component.
				- @Service is included within @ComponentScan.

			@Target:

				- @Target is a core Java annotation and not part of the Spring framework.
				- @Target specifies which types the annotation type can be assigned to:

					@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})			//Custom annotation MaxNumber can be assigned to Fields, Parameters and Methods only
					@Retention(RetentionPolicy.RUNTIME)							//Custom annotation MaxNumber is retained throughout runtime (by the JVM).
					@Qualifier
					public @interface MaxNumber
					{
					...
					}

			@Value("${<property_value>[:default_value]}"):

				- @Value allows for the insertion of values into fields directly referenced from a *.properties file.
				- @Value examples:

					// == fields ==
    			  		@Value("${game.maxNumber:20}")		//If game.maxNumber not found or *.properties file not found then will revert and insert the default 20.
    			    		private int maxNumber = 100;

	Property Files:

		- Property files are *.properties
		- Property files contain key:value pairs used within the configuration of the application.
		- Property files are located within:

			core/.../resources/config/

		- Property files enable quick modification of an applications configuration without modifiying and recompiling any of the source code.
		- Property files:

			# game properties
			game.maxNumber = 100
			game.guessCount = 10

			NB:
				- # denotes comment.
				- Space before and after = is optional.
				- game. is a prefix purely to create a namespace i.e. it could be removed if required.
		
		- Property files are accessed via @PropertySource inconjunction with @Value:

			@Configuration
			@PropertySource("classpath:config/game.properties")
			public class GameConfig {

    			    // == fields ==
    			    @Value("${game.maxNumber:20}")
    			    private int maxNumber = 100;
			}

			NB:
				- The syntax for referencing the key:value within the *.properties file is of the same format as when using properties withn the maven *.pom file e.g. ${game.maxNumber} ${java.version}
				- Successful insertion of values are reflected in the console output via 'Found key':

				> o.s.c.e.PropertySourcesPropertyResolver - Found key 'game.maxNumber' in PropertySource 'class path resource [config/game.properties]' with value of type String

		- Property files store all key@value pairs as strings, the values are converted to the appropriate type when inserted into the fields (when a value cannot be inserted an exception will be thrown).

	Spring Project Structure (via Maven MultiModule Project):

		Project Structure:

							 _______________________
							|			|
					Dependencies----| Libraries/Programs	|
					|		|_______________________|
					|		 _______________________
					|		|			|
					Plugins---------| Compilers		|
					|		|_______________________|
					|
		 _______________	|
		| pom.xml	|	|
		| (root)	|	|			...
		|		|-------|
		|		|	|
		|		|	|		 _______________________
		|_______________|	|		| Module 1		|
					|		|			|		
					|		| psvm (String args[])	|
					|		| {			|
					|		|  ...			|
					|		| }			|
					|		|			|
					|		| _____________________	|
					|		|| pom.xml	       ||
					|		||_____________________||
					|		|_______________________|
					Modules -------- _______________________
							| Module 2		|
							|			|
							| 			|
							|			|
							|			|
							|			|
							|			|
							| _____________________	|
							|| pom.xml	       ||
							||_____________________||
							|_______________________|

			- Module is a directory.
			- Module is a project within itself.
			- Module can be contained within other modules forming the following structure and naming convention:
		
				Root Module
					Child Module
					Parent Module
						Child Module
					Child Module

			- Module may contain the psvm entry point from the JVM (only x1 module may contain the psvm).

		Project Build, Compile and Run:

			1. IDE:				Press Play
			2. IDE:				Passes the pom.xml in the root folder to Maven.
			3. Maven - Build:		Parses the pom.xml file:

								- Downloads and caches all listed dependencies from mvnrepository.com that are used by Maven and the application:

									- Dependencies
										- Libraries
										- Frameworks	e.g. SpringFramework
										...

									- Plugins
										- Compilers
										...

								- Output Files:		All build outputs are located within the 'target' directory in the root.
								- Output Status:	All build status outputs are located and listed within the 'build' tab of the IDE.
								- Multi-Module:		If the pom.xml specifies that it is a multi-module project then Maven will be directed and continue to parse the pom.xml files within the respective module subdirectories.

			4. Maven - Compile:		Compiles the java source code to bytecode (typically using a downloaded Maven compiler plugin).
			5. Maven - JVM:			Once built and compiled:

								- JVM is instantiated.
								- JVM is pointed to the psvm wherever that may be.
								- JVM runs the java application as normal (using all of the dependencies listed in the pom.xml).

			6. Spring - Instantiation:	psvm(String args[])

								- Spring framework library is used to instantiate a container.
								- Spring framework library contains all of the classes/interfaces/components necessary to build a container.
								- Spring framework processes the project files to build and configure the container and the contents of the container:

									1. *.xml:		Read in *.xml which specifies all of the beans to be created and behaviour of the container.
									2. Annotations:		Scan all of the *.java files within the module using the annotations to specify all of the beans to be created and behaviour of the container.

		Spring Console Output:

			- Spring outputs to the console i.e. the entities within the spring framework i.e. the components of Spring when instantiating a container and generating beans all output to console of their status and progress to enable system monitoring and fault find:

				public static void main(String[] args)
				{
			  	    System.out.println("Test");

			  	    ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(CONFIG_LOCATION);
				}

				1. Console:	"Test"
				2. Spring:	ClassPathXmlApplicationContext creates a container in accordance with the *.xml at CONFIG_LOCATION.
				3. Console:	All of the status output contained within all of the internal referenced components is sent to console as the container is instantiated and initialised in accordnce with *.xml.

			- The psvm(String args[]) is still the entry point of the program:

				- Spring nor Maven introduce any additional layers 'before hand'.
				- The first output to console is the first line of the psvm i.e. Test.
				- Spring simply consists of a library of java classes/interfaces/components which are used, declared, defined and referenced in the standard way for all java components.  

		Module Communication:

			- Module communication is achieved as follows:

				1. Module 1 pom.xml - Open:				Open pom.xml of Module 1 that requires access to Module 2 components.
				2. Module 1 pom.xml - Add Module 2 as dependency:	Add and declare Module 2 a dependency of Module 1.

				NB: All module communication is reflected and illustrated by the dependencies within the Maven tab.

		Module Dependencies:

			- Module dependencies i.e. dependencies of the source code within that module are declared within the respective module pom.xml.
			- Module dependencies are transitive i.e. Module 1 establishing a dependency on Module 2 will in turn gain access to all of Module 2's dependencies.
			- Module dependencies are transitive therefore do not need to be explicitly repeated and declared in each module.
			- Module dependencies may include those already declared in a parent module.

		Module Versioning:

			- Module version as specified via the <version> tag within the pom.xml has the following 'rules':

				1. When adding a dependency to a module which is already included in the parent pom.xml it is not necessary to declare the <version> of that dependency (only the <groupId> and <artifactId> are needed).
				2. When adding a dependency which is another child module then the <version> must be included.

			- Module version is inherited by all child modules.
			- Module version of the parent pom.xml is exposed as a built-in Maven property ${project.version}, therefore if adding child module 2 as a dependency to child module 1 it is recommened:

				1. Use the Maven property:	${project.version}
				2. Do not hardcode the version of the child module 2.

				For should the parent pom.xml version change then it would overwrite the version of all child modules including the hardcoded version referenced in the pom.xl of child module 1.

			- Module version should ideally be completed in x1 place e.g. parent pom.xml via ${project.version} due to:

				1. Simplicity:		Simply x1 version number for the set of all modules.
				2. Management:		Easier to manage rather than individual version numbers for all modules.
				3. Robust:		Less likely to accidently break a dependency link (unlike if dependencies of other child modules are all hardcoded).

				NB: Maven does not permit the use a version property within a <parent> tags, all such elements must be hardcoded.

	Console Output Flags:

		Console output strings that are useful for debugging:

		1. Bean Registration - via @Bean:

			> Registering a bean definition via @Bean:

				- Search String: 'Registering'.
				- Bean has been successfully created, instantiated and added to the container.

		2. Bean Registration - via @Component:

			> Registering a bean definition @Component:

				- Search String: 'Identified'.
				- Bean has been successfully created, instantiated and added to the container.

		3. Autowiring - via Constructor Parameter:

			> Autowiring and injecting a bean into a parameter within a constructor parameter list:

				- Search String: 'via constructor'.
				- Bean has been successfully injected into a constructor parameter.

		4. Property Value:

			> Property value within a *.properties file injected into source code:

				- Search String: 'Found key'.
				- Successful insertion of value from *.properties file.

	Debug Techniques:

		Scroll to end:

			- Ensure to scroll to the end of any reported exception within the console output:

						Output			Issue Occurence
						___________________________________________________________________
			
				Java		Stack Trace		Issue reported at the first outputted lines
				Spring		Console Output		Issue reported at the last outputted lines

	Exceptions:

		- Spring is written in Java.
		- Spring is not an integral part of the Java language whose correctness is checked by the compiler.
		- Spring therefore uses exceptions should the instantiated container (via interface ApplicationContext) encounter a problem.
		- Spring outputs all exceptions to the console.

	Logging:

		- Logging provides the ability to:

			1. Program State:	Maintain a record of a programs state.
			2. Program Execution:	Maintain a record of a programs execution.
			3. Program Debug:	Perform debug at all stages of development including:

							Filter:		Logging via an API provides the ability to filter what is logged as opposed to sending everything to System.out.println.
							Security:	Logging provides the ability to trace access for security purposes.
							Statistics:	Logging creates data for statistical use.

		- Logging is one of the primary means of debug within microservice based architectures.
		- Logging should aim to be:

			1. Detailed
			2. Configurable
			3. Reliable

		Slf4j:

			- Slf4j is a logging framework.
			- Slf4j has x2 basic aspects:

				1. API:			Interface/facade.
							Slf4j only uses org.slf4j.Logger within applications i.e. all logging is via this interface.

				2. Implementation:	Implementation is the current operational functionality behind the API (which the API will call to provide the overall logging service).
							Implementation is an interchangable.
							Implementation is called a 'binding'.
							Implementation is relatively simple and Slf4j requires only x1 implementation at runtime which overall leads to minimal setup and configuration by the developer i.e. easy to setup and use.

		Logback:

			- Logback is an implementation of the Slf4j API interface which is a successor of log4j java project.
			- Logback is fast, flexible and reliable logging implementation written in java.
			- Logback has extensive documentation.
			- Logback logging output can be configured using a separate/external config/script file at runtime e.g. *.xml or groovy files.
			- Logback can automatically reload its configuration file upon modification.
			- Logback automatically removes old log archives.
			- Logback views the logging uses priorities which determine x5 levels of granularity, severity and verbosity:

				TRACE
				DEBUG
				INFO
				WARN
				ERROR

			- Logback can direct logging information to a variety of destinations e.g. databsae, file, email, console...
			- Logback is built and included within a project via Maven.
			- Logback has x3 main components/interfaces:

				1. logger:		Responsible for capturing logging information.
				2. appenders:		Responsible for publishing logging information to desired destinations.
				3. layouts:		Responsible for formatting logging information.

				NB: The behaviour of the above aspects can be altered by switching implementations for the above interfaces.

			- Logback utilises filters allowing them to be assembled or chained together to form complex filtering policy.
			- Logback is initialised as follows:

				1. Logback looks for a config file on the classpath in the following order:

					1. logback-test.xml
					2. logback.groovy
					3. logback.xml
					4. Cloud Service Provider provides an implementation of the Configurator interface.
					5. [Last] If above all fails Logback configures itself automatically using the BasicConfigurator which will direct all logging to the console. 
		
				2. The above ensures that if there is no config file, output is directed to the console.

			- Logger:

				- Logger is an object supplied by LogBack which can be used within the java source code to pass text for logging.
				- Logger names follow the 'hierarchical naming rule' (as that deployed in packaging):

					org.Surridge			//Ancestor
					org.Surridge.Paul		//Parent
					org.Surridge.Paul.Logger

				- Logger at the top of the heirarchy is the 'root logger':

					- Root Logger cannot be retrieved by name as for other loggers.
					- Root Logger always exists by default.

				- Logger examples:

					log.info("objA = {}", objA);

						- Returns the reference of objA if it is instantiated and not null.
						- .toString of the object replaces the {}.

					log.info("This is a message");

						- Returns simple message.

			- Layout:

				- Layouts utilise a pattern conversion:

					%date[%thread][%-5level]%logger{40} - %message%n

					2021-01-01 12:00:00,000[main][INFO](Name of Logger) - (Message Output)
					2021-01-01 12:00:00,000[main][INFO]org.Surridge.Paul.Logger - This is a test message.

					%:		Prefix of any Conversion Character
					%-5level:	Output is left justified
					%5level:	Output is right justified
					%logger{40}:	Output of logger name is reformated to fit within x40 characters

			- Configuration File:

				- Configuration file needs to be within the resources folder in project root i.e. src/main/java.

Spring Webservlet - Spring MVC

	Overview:

		- Spring MVC (or Spring Web MVC) is a web framework built on the Servlet API.
		- Spring MVC has shipped and been included within the Spring Framework from the very beginning and known as 'Spring MVC'.
		- Spring MVC is designed around the 'front controller pattern'.
		- Spring MVC utilises and is designed around a central Servlet 'DispatcherServlet':

			- DispatcherServlet provides a shared algorithm for request processing.
			- DispatcherServlet delegates to configurable components i.e. specialised beans to process requests and render the appropriate responses, providing flexibility and enabling the implementation of differing workflows.
			- DispathcerServlet expects a WebApplicationContext which is an extended interface of ApplicationContext for its own configuration, WebApplicationContext registers specialised beans automatically.	
			- DispatcherServlet is the 'front controller'.
			- DispatcherServlet receives all of the incoming requests to the application.
			- DispatcherServlet can map or redirect incoming requests to methods (annotated with @Controller) within 'Controller Classes'. 
			- DispatcherServlet is used to dispatch HTTP requests to other controllers.
			- DispatcherServlet can be registered within the application via the following x2 methods:

				1. *.xml
				2. Java Source Code

		- Spring MVC enables the use of differing View technologies to render webpages e.g. Groovy Markup, Freemarker and Thymeleaf.
		- Spring MVC integrates with other web frameworks.
		- Spring MVC provides an 'annotation-based programming model' for example @Controller @RestController can be used against components to define:

			- Request mapping
			- Request input
			- Exception handling
			- Etc... 

	MVC:

		- MVC (Model View Controller)
		- MVC divides the application into three components to separate the internal representation of information from the presentation to the user.
		
			Model:		Applications internal data, business logic and business rules.
			View:		Applications output representation e.g. as a web form or charts.
			Controller:	Applications control and invocation of particular models to perform business logic and updating the view based on the models output.

	Annotated Controllers:

		- Annotated Controllers are methods annotated with @Controller.
		- Annotated Controllers are directed incoming HTTP requests for processing.
		- Annotated Controllers have flexible method signatures.
		- Annotated Controllers do not have to extend base classes.
		- Annotated Controllers do not have to implement specific interfaces.

	View/ViewResolver:

		- View/ViewResolver interfaces enable the rendering of models in a browser without forcing the requirement to use specific view technology.
		- ViewResolver provides mapping between view names and actual views.

	JSP:

		- JSP (Java Server Pages)
		- JSP is a text document that contains x2 types of text:

			1. Static:		Static text of any text based format e.g. HTML
			2. Dynamic:		Dynamic JSP elements which enable the creation of dynamic content.

	JSTL:

		- JSTL (JavaServerPages Standard Tag Library).
		- JSTL is a component of the Java EE Web application development platform.
		- JSTL extends the JSP specification to provide a library which utilises JSP tags.
		- JSTL is a collection of useful JSP tags which forms the core functionality common to many JSP applications.
		- JSTL has tags and support for common structural tasks e.g. iteration and conditionals, manipulation of XML documents, SQL etc...
		- JSTL tags are classified into the following library tag groups:

			- Core

				<c:forEach>		Iteration over a collection
				<c:out>			Display the results of an expression
				<c:url>			Format a URL into a String and store as a variable

			- Formatting
			- SQL
			- XML
			- Spring
			- JSTL Functions

	Spring MVC Application:

		Name: 		'Research Projects/Spring MVC - 1 - Todo List'

		Summary:

			- Spring MVC Application is a web application whose output can be viewed via a browser using following URL:

				http://localhost:8080/<Maven_Project_ArtifactID>/index.html
				http://localhost:8080/todo-list/index.html

			- Spring MVC Application uses the following plugins:

				Maven WAR:		Generate and output the *.war file which encapsulates the web application.
				Maven Cargo:		Generate and run the *.war within a Apache Tomcat Servlet Container which is accessible via port 8080.

			- Spring MVC Application runs the web application situated within the 'webapp' directory of the project root:

				src/main/webapp i.e. this directory will contain the index.html

		Application Setup and Configuration:

			1. pom.xml:		Add element:		<packaging>war</packaging>		Maven will package the application as a WAR i.e. package the web application archive within a *.war file.
			2. Project Structure:	Add directory:		webapp					Directory contains all files associated with the web application e.g. *.css, *.js files.
			3. Project Structure:	Add directory:		WEB-INF					Directory contains all files which cannot be served directly to a client of the container but are accessible to the servlet, therefore these files can be used but not sent to client. WEB-INF is not part of the public document tree.
														Directory contains *.jsp, thymeleaf templates and configuration files.
			4. webapp:		Add index.html:							Enter basic html to display for testing purposes.
			5. pom.xml		Add dependency:		

							<plugin>
							    <groupId>org.apache.maven.plugins</groupId>
							    <artifactId>maven-war-plugin</artifactId>
							    <version>${maven-war.version}</version>
							    <configuration>
                    						<failOnMissingWebXml>false</failOnMissingWebXml>	//Required in order to prevent build failure due to missing webxml.xml in WEB-INF.
							    </configuration>
                					</plugin>

				NB:

					- WEB-INF | web.xml:

						- Deployment *.xml for a servlet based java web application.
						- Declares which servlets exist and which URL's they handle.
						- Functionality of the web.xml can be implemented with annotations if required, however the WAR plugin will fail if this file is not present (unless the flag <failOnMissingWebXml> is set as shown above).

					- Plugin Version:

						- Plugin version does not frequently change.
						- Plugin version can be hardcoded if required when plugin is declared within the pom.xml (but using a property is still recommended).

		Annotations:

			@Controller:

				- @Controller is itself annotated with @Component.
				- @Controller is an extension (specialisation) of @Component.
				- @Controller is therefore automatically registered by Spring when @ComponentScan is ran.
				- @Controller indicates that the annotated class is a 'web controller'.
				- @Controller indicates to Spring that the annotated class will also need to be scanned for various other associated methods e.g. @GetMapping, @PostMapping ...

			@ModelAttribute:

				- @ModelAttribute declares a method which returns a type can be included within a file which constitutes as being the View.

			@RequestMapping:

				- @RequestMapping maps incoming HTTP requests to specific @Controller methods.
				- @RequestMapping has a number of attributes which can be used for mapping:

					- URL			- Request Parameters		- Media Types
					- Http Method		- Headers

				- @RequestMapping has a number of shortcut variants (which have been available since Spring 4.3):

					Shortcut Variants	HTTP Request
					____________________________________

					@GetMapping		GET
					@PostMapping		POST
					@PutMapping		PUT
					@DeleteMapping		DELETE
					@PatchMapping		PATCH

			@RequestParam:

				- @RequestParam references a parameter supplied within the URL of HTTP request:

					http://localhost:8080/todo-list/welcome?user=Paul
					http://localhost:8080/todo-list/welcome?user=Paul&age=28

					- Request parameter 'user' whose value is 'Paul'.
					- Request parameter 'age' whose value is '28'.

			@ResponseBody:

				- @ResponseStatus informs Spring to bind the return of the annotated method to the web response body and be displayed within browser.
				- @ResponseStatus can be used for simple testing purposes.

		Architecture:

			Spring Container________________________		'context'
			|					|
                    	|  Tomcat Application Server_________	|		'servletContext'
			|  |				     |  |
                        |  |  Dispatcher Servlet__________   |  |		'dispatcherServlet'
			|  |  |				  |  |  |
			|  |  |				  |  |  |
			|  |  |				  |  |  |
			|  |  |				  |  |  |


		Application Build, Compile and Execute:

			1. Maven:		Pulls in dependencies.

			2. Maven:		Pulls in particular plugins:

							Maven WAR:

								- Builds *.war file.
								- *.war file contains all elements to run a web application into a single *.war (web application archive) file.
								- *.war file is eventually outputted into the Maven 'target' directory.

							Maven Cargo:

								- Builds an embedded Apache Tomcat Application Server.
								- *.war is run within the Tomcat Application Server.
								- *.war can be interacted and manipulation (via Maven goals) whilst running within Tomcat Application Server.

			3. Entry Point:		The entry point to the program is as follows:

							1. WebApplicationInitializer:		Spring will look for the x1 single class that implements the interface 'WebApplicationInitializer'.
							2. onStartup():				Spring will invoke the startup method.

			4. Spring Container:	Spring Container 'context' is created.

			5. Spring Container:	Spring Container is passed the webconfig.java configuration class.

							webconfig.java:		Contains all bean definitions to be housed within the Spring Container.

			6. Tomcat:		Tomcat is passed an instance of the DispatcherServlet:

							DispatcherServlet:	All incoming traffic is directed to the DispatherServlet and forwarded/delegated onto applicable @Controllers classes.

			7. Dispatcher Servlet:	Dispatcher Servlet is configured to:

							1. Startup:		Automatically startup when Tomcat starts up.
							2. Map:			Map all incoming traffic to the 'webapp' directory in the project root.

							e.g http://localhost:8080/todo-list/ 			-> webapp
							    http://localhost:8080/todo-list/welcome		-> webapp/welcome

			8. Dispatcher Servlet:	URL of the incoming traffic from the browser is passed to all @Controller classes for parsing/processing.

			9. Controller Class:	Contains methods and appropriate annotations to process the particular URL.

	MVC Request Processing:

		1. Browser makes a request to specific URL
		2. Browser 			-> Dispatcher Servlet			Dispatcher Servlet is the 'front controller' therefore is first to receive the request from the browser.
		3. Dispatcher Servlet 		-> Handler Mapping			Dispatcher Servlet passes the URL to 'Handler Mapping' to identify which controller will handle the request.
		4. Handler Mapping		-> Dispatcher Servlet			Handler Mapping returns the specific Controller and Handler Method that will handle the request.
		5. Dispatcher Servlet		-> Controller				Dispatcher Servlet invokes the particular Handler Method within the particular Controller defined to handle that particular request.
		6. Controller			-> Dispatcher Servlet			Controller (via the local Handler Method) returns the Model/View name.
		7. Dispatcher Servlet		-> View Resolver			Dispatcher Servlet passes the Model/View name to the 'View Resolver' to find the corresponding file for that model/view.
		8. View Resolver		-> Dispatcher Servlet			View Resolver returns the corresponding file to the Dispatcher Servlet.
		9. Dispatcher Servlet							Dispatcher Servlet executes the file, generating the model.
		10. Dispatcher Servlet		-> View					Dispatcher Servlet passes the model to the view.
		11. View								View content is rendered/constructed.
		12. View			-> Dispatcher Servlet			View passes the rendered content to Dispatcher Servlet.
		13. Dispatcher Servlet		-> Browser				Dispatcher Servlet builds and sends the final/complete response to the browser.

	Model and @ModelAttribute:

		- Model is an interface.
		- Model is a holder of Model Attributes.
		- Model is passed data from:

			Dispatcher Servlet -> View

		- Model can have annotations applied for use by the View when being rendered/constructed.
		- Model attributes can be added via:

			1. Model Object:	Attributes can be added to the Model object passed from the Dispatcher Servlet.
			2. Annotation:		Attributes can be added to the Model object using the @ModelAttribute annotation.

Spring Boot:

	Overview:

		- Spring Boot is a framework that enables the building of standalone, production-grade Spring based applications that can run easily and quickly.
		- Spring Boot does not require the configuration to be repeated for each application.
		- Spring Boot applications typically require very little Spring configuration which is mainly auto-configured.
		- Spring Boot main features include:

			1. Spring Boot starters:

				- Modules to quickly get started with commonly used technologies e.g. Spring MVC, JPA ...
				- Modules are pre-configured with the most commonly used library dependencies removing the need to manually research, find and configure compatible libraries.

			2. Spring Boot auto-configuration:

				- Auto-configuration is applied to many components automatically.
				- Auto-configuration removes the need to manually setup much boilerplate configuration e.g. if project contains spring-webmvc dependency, a DispatcherServlet is registered automatically.

			3. Spring Boot encorporates an easy to use embedded servlet container.

				- Web applications typically require creating and deploying *.war file to run within a Tomcat server.
				- Web applications can alternatively be housed within a self-contained *.jar file with an embedded servlet container.

			4. Spring Boot utilises elegant configuration management.

	Initializr:

		- Initializr in an online Spring Boot application generator used to create Spring Boot application from scratch.

	Project Structure:

		- Initializr will create a project of the following structure:

			Spring-Boot-Project:						Project root directory
				.idea
				.mvn
					wrapper
						maven-wrapper.jar
						maven-wrapper.properties
				src							Source directory for module
					main
						java
						resources				Project resources e.g. images, configuration files ...
							static				Static resources e.g. css, js, html ...
							templates			Template resources e.g. thymeleaf, groovy ...
							application.properties		
					test						Source directory for unit tests
						java
				.gitignore
				boot-demo.iml
				mvnw							Startup batch script used when running from console
				mvnw.cmd						Startup batch script used when running from console (Windows)
				pom.xaml

			External Libraries
				...

	ThymeLeaf:

		- ThymeLeaf is a modern server-side Java template engine used in web and standalone environments.
		- ThymeLeaf is an extensible template engine framework that enables the creation, processing and customisation of templates.
		- ThymeLeaf purpose is to provide a simple and easy way to create templates.
		- ThymeLeaf supports the processing of HTML, XML, JavaScript, CSS and plain text.
		- ThymeLeaf is able to display HTML in browsers as a static prototype i.e. HTML can be previewed without processing a template.
		- ThymeLeaf integrates well with Spring and Java EE.
		- ThymeLeaf templates are simply HTML files with ThymeLeaf attributes therefore they work just like regular HTML.
		- ThymeLeaf integrates with Spring 3, 4, 5 and Boot.
		- ThymeLeaf can be a replacement technology to JSP/JSTL.
		- ThymeLeaf supports 'fragments' i.e. smaller templates that can be reused across an application e.g. a header or footer.
		- ThymeLeaf supports 'Decoupled Template Logic' where the Template Engine is able to separate the ThymeLeaf tags from HTML.
		- Thymeleaf supports preprocessing of expressions.

			- Preprocessing enables the modification of an expression that will be executed.
			- Preprocessed expressions are surrounded by double underscores:

				${__${resultMessage}__}
				${__${T(academy.learnprogramming.util.AttributeNames).MAIN_MESSAGE}__}

				//The inner expression surrounded by double underscores are evaluated first followed by any outer expression.
				//T(JavaClass) operator denotes an instance of Type (or class), in the above case MAIN_MESSAGE is a static member of that class.

			- Preprocessing enables:

				1. Constants:			Use of constants within template.
				2. Multiple Languages:		Use of multiple languages within template.

		- Thymeleaf fragments:

			- Fragments are parts of other templates which can be be shared/imported into other templates e.g. footers, menu's...
			- Fragments are represented via the attributes:

				th:fragment

			- Fragments are inserted via the following expression:

				~{templatename::fragmentname}

			- Fragment example:

				<footer th:fragment="footerFragment">				//Fragment creation
        			    <p>This text is created for reuse</p>
    				</footer>

				<footer th:replace="~{fragments/footer::footerFragment}">	//Fragment insertion
            			    <p>-</p>
        			</footer>

		- Thymeleaf decoupled template logic:

			- Thymeleaf attributes can be defined and implemented via the x2 following means:

				1. Direct:		Attributes are defined directly in the html file.
				2. Decoupled:		Attributes are defined in a separate file (decoupled logic).

			- Thymeleaf attributes which are decoupled are stored in a separate file which has the following characteristics:

				- Location:		Stored in the same location as the corresponding templates e.g. typically within a dedicated Templates directory.
				- File Name:		Stored with the same name as the corresponding template file.
				- Extension:		Stored with the following extension:	th.xml

			- Thymeleaf decoupled templates have the following benefits:

				1. Dependency:		Templates are not dependent on Thymeleaf.
				2. Clean:		Templates can remain cleanly written in HTML, with only Thymeleaf insertion tags.
				3. Maintain:		Templates are easier to maintain.

			- Thymeleaf reads in the template file and the separate th.xml file to generate the final html file.

		- Thymeleaf Internationalisation (i18n):

			- Locale data is stored in the resources directory using *.properties:

				Default:		messages.properties
				Locale:			messgaes_XX.properties

				French:			messgaes_fr.properties
				Spanish:		messgaes_es.properties

			- The # is used to reference locale keys.

	Developer Tools:

		- Spring boot has many developer tools to assist in application development including:

			- Auto Update:

				- Auto update can sense when files have changed on the classpath and run an automatic restart of the application.
				- Auto update enables the quick editing of templates without the need to manually stop/start the application.

	Notes:

		- Logback.xml Rename:

			- Logback.xml should be renamed as Logback-Spring.xml when within a Spring Boot project.
			- This enables Spring to be fully in control of all aspects of the initailsiation process.

		- ANSI Console Output:

			- Within application.properties:

				# enable ansi output
				spring.output.ansi.enabled = always

			- This will cause the console output to be colour coded and easier to read.
