Spring

	Overview:

		- Bean is an instantiation assembled, managed and housed within a container, bean may be any:

			1. Primitive
			2. Object (POJO)

		- Bean is not a wrapper object that encloses another java object but simply an object defined and contained within a container.
		- Bean is simply the name of an object within a container, it is the name Spring gives to objects within the container.
		- Beans are referenced/tagged with an ID, name and/or alias.
		- Beans are given a default ID if one not explicitly defined within the metadata.
		- Beans are typically multiple, a container needs to have at least x1 bean but even the most simplest of enterprise applications have multiple beans.
		- Beans can cause a graph of beans to be instantiated, as a bean may reference/declare other 'collaborator' beans as internal objects/properties of that class.
		- Beans are injected into the container by the container itself i.e. the container context.

	Bean Declaration/Definition:

		- Bean is defined via x1 of the following x3 methods:

			External Files:

				1. External Files:		*.xml/*.groovy file which defines the outline of the bean e.g. its wiring to other beans/dependencies, scope and package location of its full implementation.
				
			Internal Annotations:
				
				2. Configuration Classes:	Classes annotated with @Configuration with internal @Bean methods
				3. Components:			Classes annotated with @Component, @Controller...

		- Bean is declared and defined as follows:

			1. *.xml/*.groovy:	Declare and define beans within a separate *.xml file (e.g. beans.xml).

							<bean class="<package1.package2.class1>">				//Declare a bean of class1
							<bean id="<bean_id>" class="<package1.package2.class2>">		//Declare a bean of <bean_id> of class2
							<bean id="<bean_id>" class="<package1.package2.class3>">		//Declare a bean of <bean_name> of class3
							    <property name=<bean_name> ref=<bean_reference>>
							</bean>

			2. Annotations:		Declare and define beans by using annotations directly within the source code.

							1. @Bean (Bean Methods):

								- Bean methods 'produce', 'generate' and return object/primitive beans.
								- Bean methods are invoked to instantiate and return a bean which are injected into variables.
								- Bean methods are registered by Spring when a container is instantiated.
								- Bean methods are typically collated into a single location e.g. a configuration class.
								- Bean methods are useful when additional initialisation needs to be applied to a bean before it is injected.

								Object:

									@Bean						//Bean Method returns an object as a bean
									public ClassA methodName() {
								    	    return new ClassA();
									}

									@Bean						//Bean Method returns an object which implements an interface as a bean
									public InterfaceA methodName() {
								    	    return new InterfaceAImpl();
									}

								Primitive:

									@Bean						//Bean Method returns a primitive as a bean
									public int returnField() {
								    	    return ifield;
									}

							2. @Component:

								- @Component is an annotation which declares the annotated entity as a component which is automatically registered by Spring within a @ComponentScan:

									@Component					//Class declared a bean/component of the container
									public class className
									{...}

						Configuration Classes:

							- Configuration classes are collations of @Bean i.e. dedicated classes which contain all of the bean declarations used throughout the container.
							- Configuration classes can be imported into other configuration classes via the @import annotation known as 'Modularising Configuration':

								@Import(ConfigurationClass1.class)
								public class ConfigurationClass2
								{...}

	Bean Lifecycle:

		General bean lifecycle as follows:

			1. Application starts up.
			2. Container surveys the project/source code, collating/registering all locations where a bean can be instantiated and returned.
			3. Application is running.
			4. Container instantiates beans as the running of the application dictates.
			5. Upon encountering a bean that needs to be instantiated.

				1. Container utilises the bean register looks up location/how the bean is instantiated.
				2. Container invokes mechanism.
				3. Bean is returned to calling code.
				4. Bean is injected into variable.

				If this bean has dependecies of its own, then those dependency beans are recursively pre-instantiated potentially generating a chain/graph of 'wired' dependency beans 'going back for as far a necessary'.
			
			6. Container destroys bean when required.

		NB: 'Container' here is presumably the corresponding ApplicationContext.

	Bean Instantiation + Return:

		- Bean instantiation + Return is the process where the container invokes an action/means in order to instantiate and return a bean (to ultimately be injected elsewhere):

			Returns Bean					Description
			------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			- via *.xml + Constructor:			Constructor on the bean is used to return an instance of that bean, the constructor on the bean is called as normal passing in 0 or more dependencies that the bean needs to instantiate and return that particular instance.
			- via *.xml + Static Factory Method:		Constructor on the bean maybe hidden/private and a static factory method on the bean is called passing in 0 or more dependencies that the method may or may not need to instantiate and return that particular instance.
			- via *.xml + Instance Factory Method:		Constructor on the bean maybe hidden/private and a factory method on an instance of the bean is called passing in 0 or more dependencies that the method may or may not need to instantiate and return that particular instance.
			- via @Bean					'Bean Method' contained in a @Configuration class is a factory method returning an instance of the declared bean.
			- via @Component				'Component Scanning' searches the project source code for classes annotated with @Component or a specialisation e.g. @Controller, @Service, presumably the constructor of that class is called as normal as described above.

			The container pre-instantiates and injects any arguments that are defined as parameters/dependencies that the bean needs to instantiate and return that particular instance.

		- Bean instantiation is of course distinguished from bean injection:

			Instantiation:		Instantiation is the actual creation/allocation of the bean in memory.
			Injection:		Injection is the action/process of having the container assign the instance to a variable/parameter within a class/bean within the source code.

		- Bean instantiation is carried out by the container:

			1. Source Code:		Bean is declared as a field/property/dependency within a class/bean, therefore the container will need to be inject an instance of that bean into that location/variable.
			2. Register:		Container looks through its register of beans to find a matching id, name or alias.
			3. Instantiation:	Once found using the metadata contained within the corresponding/associated BeanDefinition object is used to create an instance of that bean.
			4. Injection:		Created bean in now inserted/injected into the location/variable.

		- Bean Instantiation can be any Java bean i.e. any normal class can be pulled into a container, it does not need to have any particular interface or be constructed in any particular fashion.

	Bean Injection:

		- Beans are injected into source code:
			
			Returns Bean*						XML Element							Arguments (Injected Beans)							Description
			------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			- via *.xml + Constructor Arguments:			<constructor-arg/>						Arguments injected into local reference variable in constructor via this.	Container instantiates 'behind the scenes' and passes arguments into constructor.
			- via *.xml + Static Factory Method Arguments:		<constructor-arg/> + <factory-method/>				Arguments may or may not be used to generate and return bean.			Container instantiates 'behind the scenes' and passes arguments into static factory method.
			- via *.xml + Instance Factory Method Arguments:	<constructor-arg/> + <factory-method/> + <factory-bean/>	Arguments may or may not be used to generate and return bean.			Container instantiates 'behind the scenes' and passes arguments into instance factory method.
			- via @Bean Method Arguments:				-								Arguments may or may not be used to generate and return bean.			Container instantiates 'behind the scenes' and passes arguments into bean factory method contained within @Configuration class.


			Insert Directly Into Bean Reference Variable*
			-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			- via *.xml + Setter Method Arguments:			<property/>							Arguments injected into local reference variable in setter method via this.	Container instantiates 'behind the scenes' and passes arguments into a setter method.
			- via @Autowired:					-								-										Container instantiates 'behind the scenes' and inserts bean directly into fields/properties annotated with @Autowired.


			*Returns Bean:		Beans are injected as arguments into method parameters for the method to ultimately generate/build and return another bean to be injected/used elsewhere.
			*Insert Directly:	Beans are injected directly into existing reference variables.

	Bean Setting:

		- Bean setting of bean instances into reference variables as declared within a class is:

			- via Constructor Arguments:			Reference variable is declared within class and the constructor arguments are assigned to variable as normal using 'this' (or directly if have differing identifers).
			- via Setter Method Arguments:			"
			- via Static Factory Method Arguments:		"
			- via Instance Factory Method Arguments:	"
			- via Autowiring:				Bean is inserted/set directly into reference variable annotated with @Autowire

	Bean Definition Object:

		- Beans as defined within sources of configuration are represented as 'BeanDefinition' objects which broadly contain the metadata of the respective bean:

			Name:			Package-qualified class name i.e. the actual implementation of that bean.
			Behaviourial:		How the bean should behave within container e.g. scope, lifecycle callbacks ...
			References:		References to other internal beans/properties i.e. collaboration beans.
			Misc:			All other remaining metadata pertaining to that specific bean.

		- BeanDefinition properties include:

			Class				Autowiring Mode
			Name				Lazy Initaialisation Mode
			Scope				Initialisation Method
			Constructor Arguments		Destruction Method
			Properties

	Bean Naming:

		- Bean naming should adhere as follows:

			Identifiers:		Each bean has x1 or more identifiers either:

							1. No ID:		Container autogenerates a unique ID/Name.
							2. No ID but name(s):	Container autogenerates a unique ID (as it is not given) while still using the additional name(s) as alias.
							3. ID but no name:	Developer specified ID only.
							4. ID but x1 name:	Developer specified ID and x1 name (alias).
							5. ID but >1 names:	Developer specified ID and multiple names (alias).

						NB:

							- All identfiers must be unique in the container.
							- If it is required for the bean to be searchable via ref element in *.xml file or Service Locator lookup a name must be provided.
							- Reasons for not providing a name include 'inner beans' and 'autowiring collaborations'

			Naming Convention:	Use standard Java camel case as naming a field e.g.

							accountManager, accountService, userDao, loginController

						Good naming convention is of course critical for ensuring clarity in reading/understanding the configuration and if using Spring AOP when applying advice to a set of beans related by name.

		- Bean naming within XML configuration:

			<bean id="..." class="..." name="Paul Bob Alice"> 

				id:	Alphanumeric, may also contain special characters
				name:	One or more alias, separated using , ; or white space

			NB: id attribute is defined as an xsd:string type, however uniqueness is enforced by the container (not XML parser)

		- Bean naming as described above is automatically applied when running component scanning in the classpath i.e.

			1. Run component scan.
			2. Unnamed components have unique name automatically generated by taking the simple class name and setting the first character to lower case.
				
			NB: If in (unusual case) that first and second characters in class name are both upper case e.g. MYClass, then this is preserved (as defined by java.beans.Introspector.decapitalize)

	Bean Aliasing:

		- Bean Aliasing can be defined/applied to beans that have been defined elsewhere e.g.

			1. Bean ClassA may have been defined in another file/location.
			2. Bean ClassA can have an alias applied to it in another file/location than where it was initially declared.

		- Bean Aliasing is desirable to be applied to beans defined elsewhere e.g. in large systems where configuration is split amongst each subsystem and each subsystem having its own naming convention.

			<alias name="fromName" alias="toName"/>

			Therefore any bean within container called 'fromName' will also be known/referenced using 'toName'.

		- Bean Aliasing allows for 'namespaces' to be created for each subsystem and the overall application e.g.

			An application may have only x1 central database but need to be accessed by x2 subsystems and the overall main application:

			Container		Bean
			---------------------------------------
			Subsystem A:		'subsystemA-dataSource'
			Subsystem B:		'subsystemB-dataSource'
			Main Application:	'main-dataSource'

			Configuration:

				<alias name="main-dataSource" alias="subsystemA-dataSource"/>
				<alias name="main-dataSource" alias="subsystemB-dataSource"/>

			The respective containers can use names most appropriate to their own convention while still being able to call the same singleton database.

		- Bean Aliasing can also be implemented via attributes of @Bean methods.

	Bean Runtime Type:

		- Bean Runtime Type is the actual type that a bean variable is currently assigned i.e. the equivalent of instanceOf() in normal Java.
		- Bean Runtime Type is non-trival to determine during runtime due to:

			1. Class Name Only:		The data contained in the BeanDefinition are only text refereces of class names.
			2. Wrapped Interface:		The bean instance may, due to AOP proxying, be wrapped with a interface proxy providing limited exposure to the beans actual type i.e. exposure to interface only.

		- Bean Runtime Type is best found via BeanFactory.getType() whereby passing the specified bean name will return the type that is natrally generated for a bean of that name.

	Bean Callback Methods:

		- Bean callback methods are the methods which are 'called back' upon a particular external event e.g. click, mousemove, initialise, destroy...
		- Bean callback methods can be declared within:

			1. *.xml file:

				1. Beans attribute:	<beans default-init-method="<initialisation_method>"				Bad practice: This is inappropriate given that is applied to all beans.
				2. Bean attribute:	<bean id="..." init-method="<specific_initialisation_method>"			Bad practice: This is prone to error due to need for excessive maintenance.

			2. Annotations:

				- Annotations are considered the best practice for implementing callback methods within a modern Java spring application.
				- Annotations prevent callback names from being coupled to Spring specific interfaces.
				- Annotation based callback methods include:

					@PostConstruct					//Run the method upon the event of the bean initialisation.
					public void initMethod() {
				       	    log.info("Initialise all aspects of the bean as if a constructor");
				    	}

					@PreDestroy					//Run the method upon the event of the bean garbage collection.
				    	public void destroyMethod(){
				            log.info("Destroy all aspects of the bean as if a destructor");
				    	}

					NB: Annotations library needs to be included within the project.

	Bean Singletons:

		- Bean Singletons are simply a type which has only x1 instance within the whole container

	Bean Initialisation

		- Bean Initialisation by the conatiner/ApplicationContxt is:

			Singleton:	Eager 		Created as part of container initialisation process, therefore errors can be found earlier rather than when a bean happens to be created.
			Other:		Lazy 		Created as/when required as program is running.

		- Bean Initialisation lazy/eager can be set at global/container default state:

			<beans default-lazy-init="true">
			    <!-- No beans will be pre-instantiated, all beans including all singletons will be lazy... -->
			</beans>

		- Bean Initialisation on a Singleton bean can be set to be lazy using 'lazy-init' within the XML:

			<bean id="classA" class="com.MyApplication.ExpensiveToCreateClassA" lazy-init="true"/>		//Lazy Singleton Bean
			<bean name="classB" class="com.MyApplication.ClassB"/>						//Eager Singleton Bean

			NB: If a lazy bean is the dependency of an eager bean, then both beans are created eagerily.

	Bean Scope:

		- Bean Scope is defined within the XML.
		- Bean Scope has x6 levels (x4 only available if use web-aware ApplicationContext) and/or x1 custom/thead scope:

			Scope							Description
			------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			singleton		standard/all-scoped		Bean may be instantiated only once in IoC Container			Container can only ever have x1 instance of this bean.
			prototype		standard/all-scoped		Bean is a prototype/template used to create many instances		Container can have multiple instance of this bean.

			request			web-scoped			Bean is attached to lifecycle of single HTTP request			Each HTTP request will have its own instance of the bean created from a single bean definition.
			session			web-scoped			Bean is attached to lifecycle of single HTTP session			Each HTTP session will have its own instance of the bean created from a single bean definition.
			application		web-scoped			Bean is attached to lifecycle of ServletContxt
			websocket		web-scoped			Bean is attached to lifecycle of WebSocket			

		- Bean Scope:

			Singleton:		For all stateless beans		Beans which do not hold a particular state				e.g. DatabaseConnectionManager or DAO
			Prototype:		For all stateful beans		Beans which hold a particular state					e.g. Business logic

		- Bean Scope: Instantiation:

			Singleton:		Instantiated only when Container is instantiated (rather than during runtime).
						Instantiation of any non-singleton dependencies may or may not be 'ready' at that time e.g. may end up being null or in unexpected state.
						Instantiation of any non-singleton dependencies may require Method Injection to 'refesh' their instances.

			Prototype:		Instantiated when requested by container throughout runtime.			

		- Bean Scope: Singleton:

			- Singleton:	Only x1 instance ever exists in container.
			- Singleton:	Only x1 instance is stored in cache, all request for bean of this ID return the instance in the cache.
			- Singleton:	Only x1 instance is created when the container is created.
			- Singleton:	Only x1 instance is shared/injected into all client beans.
			- Singleton:	Differs slightly to singleton definition in Design Patterns (Gang of Four) in that:

						Design Patterns:	Singleton is created with/per ClassLoader
						Spring:			Singleton is created with/per container/bean

			- Singleton:	Defined in XML:

						<bean id="accountService" class="com.myApplication.DefaultAccountService"/>
						<bean id="accountService" class="com.myApplication.DefaultAccountService" scope="singleton"/>		//Redundant, singleton is default

		- Bean Scope: Prototype:

			- Prototype:	Multiple instances of beans in x1 container
			- Prototype:	New instance is created/returned by container when is injected into client bean e.g. via normal injection or requested via .getBean().
			- Prototype:	Defined in XML:

						<bean id="accountUser" class="com.myApplication.DefaultAccountUser" scope="prototype"/>

			- Prototype:	Lifecycle Management:

						- Spring does not handle the complete lifecycle of prototype beans (unlike other beans/scopes).
						- Spring instantiates/configures and assembles a prototype bean and then hands it over to client bean with no further interaction/management.
						- Spring initialisation callbacks are called but destruction callbacks are not.
						- Spring expects the developer to treat the bean as if it was created using 'new' in standard Java where once the bean has been created it is 'handed over' to the developer to manage its lifecycle including any tidying up and ensuring the release of any used resources.
						- Spring expects the developer to use/define the beans custom 'post-processor' callback methods to clean up that beans use of resources.

		- Bean Scope: Web: Initial Configuration:

			- Web-scope beans:

				Request
				Session
				Application
				Websocket

			- Web-scope beans require addition configuration to be defined within the web.xml file if both of the following:

				1. Servlet:			Using a Servlet web container.
				2. Request Processing:		Request processing is outside of Spring Dispatcher Servlet e.g. JSF.

				If so required follow:		https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-other-web-configuration

				NB: If the web-scoped beans are accessed within a Spring MVC project and processed by the DispatherServlet then this is not necessary for it is all handled by DispatcherServlet.

		- Bean Scope: Request

			- Request:	Bean is newly/uniquely created/associated with each and every HTTP request.
			- Request:	Bean state may be altered without concern of affecting other/subsequent beans.
			- Request:	Bean life is associated with the life of the request, once the request has completed processing the bean is disgarded.
			- Request:	Defined in XML:

						<bean id="loginAction" class="com.myApplication.LoginAction" scope="request"/>

			- Request:	Defined using annotation:

						@RequestScope
						@Component
						public class LoginAction {
						    // ...
						}

						Here:
							1. Bean returned by this @Component (which would have been registered via @ComponentScan)
							2. Bean has a scope of 'request' automtically applied.

		- Bean Scope: Session

			- Session:	Bean is newly/uniquely created/associated with each and every HTTP session.
			- Session:	Bean state may be altered without concern of affecting other/subsequent beans.
			- Session:	Bean life is associated with the life of the session, once the session is discarded the bean is disgarded.
			- Session:	Defined in XML:

						<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

			- Session:	Defined using annotation:

						@SessionScope
						@Component
						public class UserPreferences {
						    // ...
						}

						Here:
							1. Bean returned by this @Component (which would have been registered via @ComponentScan)
							2. Bean has a scope of 'session' automtically applied.

		- Bean Scope: Application

			- Application:	Bean is newly/uniquely created/associated with each and every ServletContext:

						NB: Bean is a singleton per ServletContext (not per ApplicationContext) where there may be multiple ServletContext per ApplicationContext.

			- Application:	Bean is stored/cached/exposed/visible as a single attribute of the ServletContext.
			- Application:	Bean life is associated with the life of the entire web application, once the ServletContext is discarded the bean is disgarded.
			- Application:	Bean state may be altered without concern of affecting other/subsequent beans.
			- Application:	Defined in XML:

						<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>

			- Application:	Defined using annotation:

						@ApplicationScope
						@Component
						public class AppPreferences {
						    // ...
						}

						Here:
							1. Bean returned by this @Component (which would have been registered via @ComponentScan)
							2. Bean has a scope of 'application' automtically applied.


		- Bean Scope: Websocket:

			- Websocket:	Bean life is associated with the lifecycle of a WebSocket session as applied to STOMP over WebSocket applications.

		- Bean Scope: Proxying:

			- Bean Scope can vary between beans where there may be situations when you need a singleton which collaborates with a bean of session-scope (or any situation where the x2 beans have differing lifecycles), this is achieved via:

				1. XML Configuration:

					<bean id="userPreferences" class="com.myApplication.UserPreferences" scope="session">
					    <aop:scoped-proxy/>
					</bean>

					<bean id="userManager" class="com.myApplication.UserManager">
					    <property name="userPreferences" ref="userPreferences"/>
					</bean>

					Here:

						1. UserManager is a singleton whose lifecycle is that of the container.
						2. UserPreferences is of session scope whose lifecycle is that of the current session.
						3. UserPreferences is a collaborator of UserManager but having differing lifecycles.

				2. UserManager is instantiated only once therefore so is the property UserPreferences (but of course this changes with each session).
				3. UserManager therefore uses an <aop:scoped-proxy> eqivalent of UserPreferences.
				4. Container creates a object which exposes the same public interface as UserPreferences and is used as an intermediary to the real/current session scoped instance of UserPreferences.
				5. UserManager is not aware and knows no difference.
				6. UserManager invokes a method on the proxy at which point the proxy fetches the current instance and delegates the invocation onto the 'real' UserPreferences. 

				NB: There are other alternative ways of retrieving the current session instance:

					1. ObjectFactory<MyTargetBean>:		Declare injection point (constructor/setter argument or @Autowired field) as a ObjectFactory<MyTargetBean>, then call getObject() to get current instance.
					2. ObjectProvider<MyTargetBean>:	Declare injection point (constructor/setter argument or @Autowired field) as a ObjectProvider<MyTargetBean>, then call getIfAvailable() and getIfUnique() to get current instance.
					3. Provider<MyTargetBean>:		Declare injection point (constructor/setter argument or @Autowired field) as a Provider<MyTargetBean>, then call get() to get current instance.

					For more info on how to use the above:

						- https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-websocket
						- https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html

				NB: Proxying as described above can be applied between beans which are both singletons, where the reference going through an intermediate proxy that is serializable and therefore able to re-obtain the target singleton bean on deserialization.
				NB: When declaring a bean <aop:scoped-proxy/> which is also of scope=prototype, every method call on the container created proxy leads to the creation of a new target instance to which the method call is delegated/forwarded onto.

			- Beans created to become proxy for beans of differing scopes/lifecycles (via <aop:scoped-proxy/>) is via CGLIB.

				NB: Proxies created via CGLIB do not delegate to private methods, attempting to call a private method will not delegate to the actual scoped target object.

			- Beans created using the standard JDK interface-based proxies can be an alternative to CGLIB based proxies by setting attribute proxy-target-class="false": 

				<bean id="userPreferences" class="com.myApplication.UserPreferences" scope="session">
				    <aop:scoped-proxy proxy-target-class="false"/>
				</bean>

				NB: Using JDK interface-based proxies removes the need for additional libraries to be included in the classpath.
				NB: Using JDK interface-based proxies requires that the target bean implement an interface which the collaborators can use to interact with the current target bean.

					https://docs.spring.io/spring-framework/reference/core/aop/proxying.html


			https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-injection




























 
