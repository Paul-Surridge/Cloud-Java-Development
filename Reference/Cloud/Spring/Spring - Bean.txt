Spring

	Overview:

		- Bean is an instantiation assembled, managed and housed within a container, bean may be any:

			1. Primitive
			2. Object (POJO)

		- Bean is not a wrapper object that encloses another java object but simply an object defined and contained within a container.
		- Bean is simply the name of an object within a container, it is the name Spring gives to objects within the container.
		- Bean is given a default ID if one not explicitly defined within the metadata.
		- Beans are typically multiple, a container needs to have at least x1 bean but even the most simplest of enterprise applications have multiple beans.
		- Bean can cause a graph of beans to be instantiated, as a bean may reference/declare other beans naturally as internal objects/properties of that class.

	Purpose:

		- ...

	Bean Declaration/Definition:

		- Bean is defined via x1 of the following x3 methods:

			External Files:

				1. External Files:		*.xml/*.groovy file which defines the outline of the bean e.g. its wiring to other beans/dependencies, scope and package location of its full implementation.
				
			Internal Annotations:
				
				2. Configuration Classes:	Classes annotated with @Configuration with internal @Bean methods
				3. Components:			Classes annotated with @Component, @Controller...

		- Bean is declared and defined as follows:

			1. *.xml/*.groovy:	Declare and define beans within a separate *.xml file (e.g. beans.xml).

							<bean class="<package1.package2.class1>">				//Declare a bean of class1
							<bean id="<bean_id>" class="<package1.package2.class2>">		//Declare a bean of <bean_id> of class2
							<bean id="<bean_id>" class="<package1.package2.class3>">		//Declare a bean of <bean_name> of class3
							    <property name=<bean_name> ref=<bean_reference>>
							</bean>

			2. Annotations:		Declare and define beans by using annotations directly within the source code.

							1. @Bean (Bean Methods):

								- Bean methods 'produce', 'generate' and return object/primitive beans.
								- Bean methods are invoked to instantiate and return a bean which are injected into variables.
								- Bean methods are registered by Spring when a container is instantiated.
								- Bean methods are typically collated into a single location e.g. a configuration class.
								- Bean methods are useful when additional initialisation needs to be applied to a bean before it is injected.

								Object:

									@Bean						//Bean Method returns an object as a bean
									public ClassA methodName() {
								    	    return new ClassA();
									}

									@Bean						//Bean Method returns an object which implements an interface as a bean
									public InterfaceA methodName() {
								    	    return new InterfaceAImpl();
									}

								Primitive:

									@Bean						//Bean Method returns a primitive as a bean
									public int returnField() {
								    	    return ifield;
									}

							2. @Component:

								- @Component is an annotation which declares the annotated entity as a component which is automatically registered by Spring within a @ComponentScan:

									@Component					//Class declared a bean/component of the container
									public class className
									{...}

						Configuration Classes:

							- Configuration classes are collations of @Bean i.e. dedicated classes which contain all of the bean declarations used throughout the container.
							- Configuration classes can be imported into other configuration classes via the @import annotation known as 'Modularising Configuration':

								@Import(ConfigurationClass1.class)
								public class ConfigurationClass2
								{...}


	Bean Instantiation:

		- Bean instantiation i.e. bean instance is obtained within a container:

			- via Constructor:			The constructor on the bean is called as normal passing in 0 or more dependencies that the bean needs to instantiate and return that particular instance.
			- via Static Factory Method:		The constructor may be hidden/private and a static factory method on the bean is called passing in 0 or more dependencies that the method may or may not need to instantiate and return that particular instance.
			- via Instance Factory Method:		The constructor may be hidden/private and a factory method on the bean is called passing in 0 or more dependencies that the method may or may not need to instantiate and return that particular instance.
			- via @Bean				'Bean Method' contained in a @Configuration class is a factory method returning an instance of the declared bean.
			- via @Component			'Component Scanning' searches the project source code for classes annotated with @Component or a specialisation e.g. @Controller, @Service, presumably the constructor of that class is called as normal as described above.

			The container pre-instantiates and injects any arguments that are defined as parameters/dependencies that the bean needs to instantiate and return that particular instance.

		- Bean instantiation is of course distinguished from bean injection:

			Instantiation:		Instantiation is the actual creation/allocation of the bean in memory.
			Injection:		Injection is the action/process of having the container assign the instance to a variable/parameter within a class/bean within the source code.

		- Bean instantiation is carried out by the container:

			1. Source Code:		Bean is declared as a field/property/dependency within a class/bean, therefore the container will need to be inject an instance of that bean into that location/variable.
			2. Register:		Container looks through its register of beans to find a matching id, name or alias.
			3. Instantiation:	Once found using the metadata contained within the corresponding/associated BeanDefinition object is used to create an instance of that bean.
			4. Injection:		Created bean in now inserted/injected into the location/variable.

		- Bean Instantiation can be any Java bean i.e. any normal class can be pulled into a container, it does not need to have any particular interface or be constructed in any particular fashion.
		- Bean Instantiation can be carried out using x3 ways (as specified within the class attribute of <bean/> within *.xml file as described above):

	Bean Injection:

		- Bean injection is:

			- via Constructor Arguments:			Container instantiates 'behind the scenes' and passes arguments into constructor.
			- via Setter Method Arguments:			Container instantiates 'behind the scenes' and passes arguments into a setter method.
			- via Static Factory Method Arguments:		Container instantiates 'behind the scenes' and passes arguments into static factory method.
			- via Instance Factory Method Arguments:	Container instantiates 'behind the scenes' and passes arguments into instance factory method.
			- via Bean Method Arguments:			Container instantiates 'behind the scenes' and passes arguments into bean factory method contained within @Configuration class.
			- via Autowiring:				Container instantiates 'behind the scenes' and inserts those into instance directly into fields/properties annotated with @Autowire.

	Bean Setting:

		- Bean setting of bean instances into reference variables as declared within a class is:

			- via Constructor Arguments:			Reference variable is declared within class and the constructor arguments are assigned to variable as normal using 'this' (or directly if have differing identifers).
			- via Setter Method Arguments:			"
			- via Static Factory Method Arguments:		"
			- via Instance Factory Method Arguments:	"
			- via Autowiring:				Bean is inserted/set directly into reference variable annotated with @Autowire

	Bean Definition Object:

		- Beans as defined within sources of configuration are represented as 'BeanDefinition' objects which broadly contain the metadata of the respective bean:

			Name:			Package-qualified class name i.e. the actual implementation of that bean.
			Behaviourial:		How the bean should behave within container e.g. scope, lifecycle callbacks ...
			References:		References to other internal beans/properties i.e. collaboration beans.
			Misc:			All other remaining metadata pertaining to that specific bean.

		- BeanDefinition properties include:

			Class				Autowiring Mode
			Name				Lazy Initaialisation Mode
			Scope				Initialisation Method
			Constructor Arguments		Destruction Method
			Properties

	Bean Naming:

		- Bean naming should adhere as follows:

			Identifiers:		Each bean has x1 or more identifiers either:

							1. No ID:		Container autogenerates a unique ID/Name.
							2. No ID but name(s):	Container autogenerates a unique ID (as it is not given) while still using the additional name(s) as alias.
							3. ID but no name:	Developer specified ID only.
							4. ID but x1 name:	Developer specified ID and x1 name (alias).
							5. ID but >1 names:	Developer specified ID and multiple names (alias).

						NB:

							- All identfiers must be unique in the container.
							- If it is required for the bean to be searchable via ref element in *.xml file or Service Locator lookup a name must be provided.
							- Reasons for not providing a name include 'inner beans' and 'autowiring collaborations'

			Naming Convention:	Use standard Java camel case as naming a field e.g.

							accountManager, accountService, userDao, loginController

						Good naming convention is of course critical for ensuring clarity in reading/understanding the configuration and if using Spring AOP when applying advice to a set of beans related by name.

		- Bean naming within XML configuration:

			<bean id="..." class="..." name="Paul Bob Alice"> 

				id:	Alphanumeric, may also contain special characters
				name:	One or more alias, separated using , ; or white space

			NB: id attribute is defined as an xsd:string type, however uniqueness is enforced by the container (not XML parser)

		- Bean naming as described above is automatically applied when running component scanning in the classpath i.e.

			1. Run component scan.
			2. Unnamed components have unique name automatically generated by taking the simple class name and setting the first character to lower case.
				
			NB: If in (unusual case) that first and second characters in class name are both upper case e.g. MYClass, then this is preserved (as defined by java.beans.Introspector.decapitalize)

	Bean Aliasing:

		- Bean Aliasing can be defined/applied to beans that have been defined elsewhere e.g.

			1. Bean ClassA may have been defined in another file/location.
			2. Bean ClassA can have an alias applied to it in another file/location than where it was initially declared.

		- Bean Aliasing is desirable to be applied to beans defined elsewhere e.g. in large systems where configuration is split amongst each subsystem and each subsystem having its own naming convention.

			<alias name="fromName" alias="toName"/>

			Therefore any bean within container called 'fromName' will also be known/referenced using 'toName'.

		- Bean Aliasing allows for 'namespaces' to be created for each subsystem and the overall application e.g.

			An application may have only x1 central database but need to be accessed by x2 subsystems and the overall main application:

			Container		Bean
			---------------------------------------
			Subsystem A:		'subsystemA-dataSource'
			Subsystem B:		'subsystemB-dataSource'
			Main Application:	'main-dataSource'

			Configuration:

				<alias name="main-dataSource" alias="subsystemA-dataSource"/>
				<alias name="main-dataSource" alias="subsystemB-dataSource"/>

			The respective containers can use names most appropriate to their own convention while still being able to call the same singleton database.

		- Bean Aliasing can also be implemented via attributes of @Bean methods.

	Bean Runtime Type:

		- Bean Runtime Type is the actual type that a bean variable is currently assigned i.e. the equivalent of instanceOf() in normal Java.
		- Bean Runtime Type is non-trival to determine during runtime due to:

			1. Class Name Only:		The data contained in the BeanDefinition are only text refereces of class names.
			2. Wrapped Interface:		The bean instance may, due to AOP proxying, be wrapped with a interface proxy providing limited exposure to the beans actual type i.e. exposure to interface only.

		- Bean Runtime Type is best found via BeanFactory.getType() whereby passing the specified bean name will return the type that is natrally generated for a bean of that name.

	Bean Callback Methods:

		- Bean callback methods are the methods which are 'called back' upon a particular external event e.g. click, mousemove, initialise, destroy...
		- Bean callback methods can be declared within:

			1. *.xml file:

				1. Beans attribute:	<beans default-init-method="<initialisation_method>"				Bad practice: This is inappropriate given that is applied to all beans.
				2. Bean attribute:	<bean id="..." init-method="<specific_initialisation_method>"			Bad practice: This is prone to error due to need for excessive maintenance.

			2. Annotations:

				- Annotations are considered the best practice for implementing callback methods within a modern Java spring application.
				- Annotations prevent callback names from being coupled to Spring specific interfaces.
				- Annotation based callback methods include:

					@PostConstruct					//Run the method upon the event of the bean initialisation.
					public void initMethod() {
				       	    log.info("Initialise all aspects of the bean as if a constructor");
				    	}

					@PreDestroy					//Run the method upon the event of the bean garbage collection.
				    	public void destroyMethod(){
				            log.info("Destroy all aspects of the bean as if a destructor");
				    	}

					NB: Annotations library needs to be included within the project.

	Bean Singletons:

		- Bean Singletons are simply a type which has only x1 instance within the whole container

















 
