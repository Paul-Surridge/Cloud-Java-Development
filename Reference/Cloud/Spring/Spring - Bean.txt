Spring

	Bean:

		Overview:

			- Bean is an instantiation assembled, managed and housed within a container, bean may be any:

				1. Primitive
				2. Object (POJO)

			- Bean is not a wrapper object that encloses another java object but simply an object defined and contained within a container.
			- Bean is simply the name of an object within a container, it is the name Spring gives to objects within the container.
			- Bean is given a default ID if one not explicitly defined within the metadata.
			- Beans are typically multiple, a container needs to have at least x1 bean but even the most simplest of enterprise applications have multiple beans.
			- Bean can cause a graph of beans to be instantiated, as a bean may reference/declare other beans naturally as internal objects/properties of that class.

		Bean Definition Object:

			- Beans as defined within sources of configuration are represented as 'BeanDefinition' objects which broadly contain the metadata of the respective bean:

				Name:			Package-qualified class name i.e. the actual implementation of that bean.
				Behaviourial:		How the bean should behave within container e.g. scope, lifecycle callbacks ...
				References:		References to other internal beans/properties i.e. collaboration beans.
				Misc:			All other remaining metadata pertaining to that specific bean.

			- BeanDefinition properties:

				Class			Autowiring Mode
				Name			Lazy Initaialisation Mode
				Scope			Initialisation Method
				Constructor Arguments	Destruction Method
				Properties

		Bean Naming:

			- Bean naming is as follows:

				Identifiers:		Each bean has x1 or more identifiers either:

								1. No ID:		Container autogenerates a unique ID/Name
								2. No ID but name(s):	Container autogenerates a unique ID (as it is not given) while still using the additional name(s) as alias
								3. ID but no name:	Developer specified ID only
								4. ID but x1 name:	Developer specified ID and x1 name (Alias)
								5. ID but >1 names:	Developer specified ID and multiple names (Alias)

							NB:

								- All identfiers must be unique in the container.
								- If it is required for the bean to be searchable via ref element or Service Locator lookup a name must be provided.
								- Reasons for not providing a name include 'inner beans' and 'autowiring collaborations'

				Naming Convention:	Use standard Java camel case as naming a field e.g.

								accountManager, accountService, userDao, loginController

							Good naming convention is of course critical for ensuring clarity in reading/understanding the configuration and if using Spring AOP when applying advice to a set of beans related by name.

			- Bean naming with XML configuration:

				<bean id="..." class="..." name="Paul Bob Alice"> 

					id:	Alphanumeric, may also contain special characters
					name:	One or more alias, separated using , ; or white space

				NB: id attribute is defined as an xsd:string type, however uniqueness is enforced by the container (not XML parser)

			- Bean naming as described above is automatically applied when running componet scanning in the classpath i.e.

				1. Component scanning
				2. Unnamed components have unique name automatically generated by taking the simple class name and setting the first character to lower case.
				
				NB: If in (unusual case) that first and second characters in class name are both upper case e.g. MYClass, then this is preserved (as defined by java.beans.Introspector.decapitalize)

		Bean Aliasing:

			- Bean Aliasing can be defined/applied to beans that have been defined elsewhere i.e. applying an alias is not only restricted to being applied where the bean is actually defined.
			- Bean Aliasing is desirable to be applied to beans defined elsewhere e.g. in large systems where configuration is split amongst each subsystem and each subsystem having its own naming convention.

				XML File:

					<alias name="fromName" alias="toName"/>

					Therefore any bean within container called 'fromName' will also be known/referenced using 'toName'.

			- Bean Aliasing allows for 'namespaces' to be created for each subsystem and the overall application e.g.:

				An application may have only x1 central database but need to be accessed by x2 subsystems and the overall main application:

				Container		Bean
				---------------------------------------
				Subsystem A:		'subsystemA-dataSource'
				Subsystem B:		'subsystemB-dataSource'
				Main Application:	'main-dataSource'

				Configuration:

					<alias name="main-dataSource" alias="subsystemA-dataSource"/>
					<alias name="main-dataSource" alias="subsystemB-dataSource"/>

				The respective containers can use names most appropriate to their own convention while still being able to call the same singleton database.

			- Bean Aliasing can also be provided via attributes of @Bean methods.

		Bean Instantiation:

			- Bean Instantiation should be distinguished from Bean Injection, instantiation is of course the actual creation of the bean in memory 'behind the scenes' before it is injected into another class.
			- Bean Instantiation is carried out by the container:

				1. Source code declares a bean to be injected.
				2. Container looks through the bean register to that of match id, name or alias.
				3. Once found using the metadata contained within the corresponding BeanDefinition object an instance of that bean is created/acquired and injected as required.

			- Bean Instantiation can be any Java bean i.e. any normal class can be pulled into a container, it does not need to have any particular interface or be constructed in any particular fashion.
			- Bean Instantiation can be carried out using x3 ways (as specified within the class attribute of <bean/> within *.xml file as described above):

				1. Constructor:			Bean is instantiated as normal by using the constructor of that class.
								Depending upon the type of IoC being used it may be necessary to ensure that the class has/defines a default (no-argument) constructor.

				2. Static Factory Method:	Typically used to call static factories in legacy code.

				3. Instance Factory Method:	

				NB: JavaBeans:

					- Class with only x1 default (no-argument) constructor.
					- Class with only appropriate getter/setter for each property.
					- Many Spring developers use this form prefering 'true' JavaBeans, however Spring is not restricted to only this form of bean, non-bean style can of course be incorporated.

		Bean Runtime Type:

			- Bean Runtime Type is the actual type that a bean variable is assigned, the equivalent of instanceOf() in normal Java.
			- Bean Runtime Type is non-trival to determine during runtime due to:

				- The data contained in the BeanDefinition are only text refereces of class names.
				- The bean instance may due to AOP proxying be wrapped with a interface proxy providing limited exposure to the beans actual type (with exposure to interface only).

			- Bean Runtime Type is best found via BeanFactory.getType() whereby passing the specified bean name will return the type that is natrally generated for a bean of that name.

		Bean Declaration/Definition:

			- Bean is defined via following x3 methods:

				External Files:

					1. External Files:		*.xml/*.groovy
				
				Internal Annotations:
				
					2. Configuration Classes:	Classes annotated with @Configuration with internal @Bean methods
					3. Annotated Components:	Classes annotated with @Component, @Controller...

			- Bean is declared and defined as follows:

				1. *.xml/*.groovy:	Declare and define beans within a separate *.xml file (e.g. beans.xml).

								<bean class="<package1.package2.class1>">				//Declare a bean of class1
								<bean id="<bean_id>" class="<package1.package2.class2>">		//Declare a bean of <bean_id> of class2
								<bean id="<bean_id>" class="<package1.package2.class3>">		//Declare a bean of <bean_name> of class3
								    <property name=<bean_name> ref=<bean_reference>>
								</bean>

				2. Annotations:		Declare and define beans by using annotations directly within the source code.

								1. @Bean (Bean Methods):

									- Bean methods 'produce', 'generate' and return object/primitive beans.
									- Bean methods are invoked to instantiate and return a bean which are injected into variables.
									- Bean methods are registered by Spring when a container is instantiated.
									- Bean methods are typically collated into a single location e.g. a configuration class.
									- Bean methods are useful when additional initialisation needs to be applied to a bean before it is injected.

									Object:

										@Bean						//Bean Method returns an object as a bean
										public ClassA methodName() {
									    	    return new ClassA();
										}

										@Bean						//Bean Method returns an object which implements an interface as a bean
										public InterfaceA methodName() {
									    	    return new InterfaceAImpl();
										}

									Primitive:

										@Bean						//Bean Method returns a primitive as a bean
										public int returnField() {
									    	    return ifield;
										}

								2. @Component:

									- @Component is an annotation which declares the annotated entity as a component which is automatically registered by Spring within a @ComponentScan:

										@Component					//Class declared a bean/component of the container
										public class className
										{...}

							Configuration Classes:

								- Configuration classes are collations of @Bean i.e. dedicated classes which contain all of the bean declarations used throughout the container.
								- Configuration classes can be imported into other configuration classes via the @import annotation known as 'Modularising Configuration':

									@Import(ConfigurationClass1.class)
									public class ConfigurationClass2
									{...}

		Bean Callback Methods:

			- Bean callback methods are the methods which are 'called back' upon a particular external event e.g. click, mousemove, initialise, destroy...
			- Bean callback methods can be declared within:

				1. *.xml file:

					1. Beans element attribute:	<beans default-init-method="<initialisation_method>"				Bad practice: This is inappropriate given that is applied to all beans.
					2. Bean element attribute:	<bean id="..." init-method="<specific_initialisation_method>"			Bad practice: This is prone to error due to need for excessive maintenance.

				2. Annotations:

					- Annotations are considered the best practice for implementing callback methods within a modern Java spring application.
					- Annotations prevent callback names from being coupled to Spring specific interfaces.
					- Annotation based callback methods include:

						@PostConstruct					//Run the method upon the event of the bean initialisation.
					    	public void initMethod() {
					       	    log.info("Initialise all aspects of the bean as if a constructor");
					    	}

						@PreDestroy					//Run the method upon the event of the bean garbage collection.
					    	public void destroyMethod(){
					            log.info("Destroy all aspects of the bean as if a destructor");
					    	}

						NB: Annotations library needs to be included within the project.
