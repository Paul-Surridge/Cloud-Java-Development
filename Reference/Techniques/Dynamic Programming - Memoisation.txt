Dynamic Programming - Memoisation

	Overview:

		- Memoisation is typically utilised during recursive method calls.
		- Memoisation is where the result of repeated input calculations are stored/retrieved (rather than repeatedly calculate the same input).
		- Memoisation typically involve the utilisation of a O(1) lookup table e.g. hashmap.
		- Memoisation can only be applied to immutable data e.g. integers/strings not whole arrays.
		- Memoisation can be applied when the subproblems yield a result which is and always will be consistent for that particular input (where there will be no wavering aspects which will cause that to be otherwise). 

	Typicaly Approach:

		Call Tree:

			- To gain an understanding of where memoisation can be used.
			- Create a call tree which illustrates how many times a recursive method is called and which arguments are passed.
			- Given the below call tree, find the fib(7):

				      	      fib(7)
				 _______________|_______________
				|				|
				fib(5)				fib(6)
				|_______			|_______
				|	|			|	|
				fib(3)	fib(4)			fib(4)	fib(5)
				|	|			|	|


			- It becomes apparent that fib() gets called and passed the same argument many times.

		Hash Table:

			- Therefore store the values of all outputs of fib() as they are calculated.
			- Whereby:

				If fib(x) has already been calculated:		Get value from hashtable.
				If fib(x) has not already been calculated:	Calculate value and store in hashtable.

		Paradigm:

			- Each node should store its own result of the overall question being asked.
			- So that any other node of the same value does not need to be re-calculated and can be pull out of memo object.

				Original Input Value
				|_______________________________________________________________
				|				|				|
				Calculated Input Value 1	Calculated Input Value 2	Calculated Input Value 3
				|				|				|

			- Therefore if the question being asked:

				"What is the shortest path"				Each node should store the shortest path for that particular input value.
				"What is the number of unique combinations" 		Each node should store the number of unique combination for that particular input value.

			- The result is passed back up the tree to root to form the result using the original input value.
			- Memoisation can only begin once a node contains only base case and its calculated value forms the initial entries in the memo hashtable.
			- Components:

				Question:		The original question being asked and purpose of recursion/memoisation.
							The return type of the question maybe a boolean, integer or any other data type, each node must return the same data type.

				Original Input:		The value that is originally supplied by the external program, it is the ultimate result that is required.

				Node:			The intermediate or sub-input values to the recursive method calls.

				Base Case:		The node is valid and its path from top root node satifies the original question.
							The node will always be a leaf node.
							The total number of base cases will always = Size of any results that need to be fully calculated (all other nodes are calculated after the base cases by extract the pre-calculate values from the memo hashtable).
							The base cases form the foundation of the memo hashtable and recalled when building the paths of the higher values when being entered into the memo hashtable.

				Invalid Case:		Node is invalid and path is invalid and does not satifies the original question.

				Ongoing Case:		Node is valid and path is still valid but does not satisfy the original question, more recursive branching required to reach base or invalid case.

	Steps:

		Given a particular problem:

			1. Breakdown the larger problem into a series of smaller repeated/identical problems.
			2. Find the base case:

				Base Case:	The smallest case where no further recursive call is required.
				Conditional:	The base case would be checked at the start of the recursive function and return a constant value.
				Tree Leaves:	The base case would be considered the 'leaves' of the generated call tree.

			3. Once the base case is known, visualise the issue as a call tree.
			4. Each 'edge' of the call tree should decrease the size of the problem.
			5. Implement the call tree using recursion (trees are highly applicable to recursive/dynamic programming).
			6. Once working this would form the 'bute force' or 'naive' solution.

		Efficency:

			7. Increase efficency by introducing memoisation, whereby storing results and recalling if that particular calculation has already been done before.

	Base/Trival/Smallest Case:

		- Base case and the need to identify the base case is common to all dynamic programming problems.
		- Base case is typically dependent on the expected return type of the question:

			Return Type:		Base Case
			__________________________________

			int			0
			String			""
			Boolean			F
			Array			[] (Empty Array)

		- Base case is typically the 'smallest', 'largest' possible input or an input which satifies a particular criterion, whose result is self-evident or axiomatic.
		- Base case result is used to ultimately build up the results to the question being asked.

	Methodology:

		- Dynamic programming has x2 approaches:

			1. Recursive:		Utilising memoisation.
			2. Iteratively:		Utilising tabulation.
