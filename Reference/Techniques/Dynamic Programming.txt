Dynamic Programming

	Overview:

		Dynamic Programming is a technique that can be applied to any valid context e.g.

			1. 1D/2D Array
			2. String
			3. Any problem which can be broken down into a smaller subset of problems which have the following x2 characteristics:

				1. Identical Subproblems:

					- The result of the problem can be found by applying the same procedure to smaller inputs.
					- The result of the problem for these smaller inputs can combine to find the result of an incrementally larger input, this process is repeated until the initial (largest input) is found.

				2. Optimal Substructure:

					- The optimal solution to the problem is formed from the optimal solutions of its subproblems.
					- The optimal solutions of the subproblems can be combined to find the optimal solution to the overall problem.

				NB: Greedy and Divide and Conquer consist of subproblems but they do not overlap, therefore are not dynamic programming.

		Dynamic Programming is a subset of 'Divide and Conquer' technique which involves breaking down an initial problem into a smaller subsets of the same problem but with smaller input values.
		Dynamic Programming is considered more 'difficult' than Greedy or Divide and Conquer, therefore should only be considered once these two options have been discounted.
		Dyanmic Programming is typically applied to the following question types:

			Optimal:	What is the longest, shortest, maximum, minimum of something?
					Recurrence Relation contains a search for the min/max of previous states:

						dp(i) = Math.Max(dp(i-1), dp(i-2) ...)

					Base case is typically 0 e.g. when going out of bounds

			Counting:	What are the distinct number of ways something can be done?
					Recurrence Relation contains the addition of previous states:

						dp(i) = dp(i-1) + dp(i-2)

					Base case is typically predefined with a value e.g. dp[1] = 1, dp[2] = 3									

	Top-Down/Bottom-Up:

		DP can be completed using one of two forms:

			1. Top-Down: Recursion with Memoisation

				- Initial input is root of call tree with the base cases (most trival/smallest/axiomatic input) forming the leaves with cached values terminating branches
				- Easier to derive/write
				- No ordering required
				- Implemented via:	Recursion + HashMap

				Execution:

					Even though it is called 'Top-Down' the result is still 'built up' from the bottom base cases.

					1. Traverse to Base Case:		Traverse all the way down the call tree in DFS/preOrder until it reaches a base case.
					2. Base Case in Memo:			Base case is already stored in the memo, therefore the recursive call simply returns the base case result.
					3. Find Parent Result:			Base case result forms part of the result for the immediate parent node ('Base Case + 1' is a sense).
					4. Store Parent Result:			Parent node result is stored in memo.
					5. Traverse rest of call tree:		Rest of call tree is traversed is the input does not already exist in memo.
					6. Built Final Result:			Until the result of all of the child nodes is known and used to construct the final result of the initial input.

					Memoisation should be applied when the subproblems yield a result which is and always will be consistent for that particular input (where there will be no wavering aspects which will cause that to be otherwise). 

			2. Bottom-Up: Tabulation

				- Overall solution is built up from the base cases smallest/most trivial inputs to the overall solution
				- Faster, less overhead, less space 
				- Correct ordering required
				- Implemented via:	Nested loops + Array

			NB: A solution which can be found through just recursion (without memoisation) is not dyanmic programming it is just recursion.

		Top-Down and Bottom-Up are interchangable i.e. what can/is implemented in Top-Down and be converted into Bottom-Up and vice versa.

	Execution:

		- Execution nature is actually very similar if not considered the same between Top-Down and Bottom-Up.
		- Execution builds the Final Result from the base cases up i.e. bottom-up in both techniques.
		- Execution should simply be categorised 'via Recursion + Memoisation' or 'Iteration'.

	Context:

		- Context is the environment or scenario that forms the particular question.
		- Context is the description and general surrounding of the question being asked.
		- Context will contain description of:

			1. State
			2. State Variables
			3. Initial Input
			4. Final Result (that is required)

	Initial Input:

		- Initial Input is the 'large' input that is presented in the question.
		- Initial Input is what forms the Final Result.
		- Incrementally (recursively or iteratively) from the base cases the Final Result to the Initial Input is found. 

	State and State Variables:

		State Variables:	State variables are any variable described within the question or any variable inherent within the input data structure.
					State variables correspond to the number of dimensions a question has.
					State variables should be able to completely describe the state i.e. the environment in that particular state.
					State variables should never be constants.
					State variables are the input(s) variables to each node on call tree. 

		State:			State of the context.
					State is determined by the particular value of the state variables.
					State is determined by the particular value of the inputs.
					State and the range of available states is determined by the range in the value of the state variables

						State 1:	Base Case			Smallest/Trivial Input (determined axiomatically)
						State 2:	Intermittent states		Incrementally larger inputs
						State 3:	Intermittent states		...
						State 4:	Intermittent states		...
						...
						State n:	When the environment is in the state of the initial input

						For example:

							State	fib()
							-------------
							1	1
							2	1
							3	2
							4	3
							...
							n	fib(n-1) + fib(n-2)

					State is the value of the input that is supplied to calculate the result of that input as built up from smaller inputs (which are typically cached).
					State is the 'stage' within the overall process of cconstructing the Final Result for the Initial Input.
					State is the node within the Call Tree.
					State will have its own particular result (which is stored within cache).

		States Total:		State Total i.e the total number of possible states the context may have is:

						(State Variable 1 * Range of values for State Variable 1) * (State Variable 2 * Range of values for State Variable 2) * ... * (State Variable n * Range of values for State Variable n)

						NB: Reducing the number of states will reduce the Time or Space (or both) Complexity, this process is known as State Reduction:

							Space Complexity:	

		State Reduction:	State Reduction is achieved via:

						Context/Question:		Careful observation and assessment of the context and the associated question.
						Recurrence Relation:		Careful observation and assessment within the Recurrence Relation.

					State Reduction (unfortunately) can not be achieved using a standard form/approach but is generally identified via:

						State Variable Relation:	Are there any relationship between the state variables which could be expressed within the Recurrence Relation to determine the value of another state variable?
						Non-Iterative:			If the Recurrence Relation does not require iteration then it is likely that some form State Reduction is possible.

					State Reduction effects on time/space complexity are generally only applicable as follows:

						Space Complexity Reduction:	Applicable to Bottom-Up only
						Time Complexity Reduction:	Applicable to both Bottom-Up and Top-Down

		For example, state variables may include any of the following:

			Index:

				Given Initial Input:	[0 1 2 3 4 5 6], the only 'things' which can become a state variable for a 1D array is an index (there can be nothing else)

				1: 	dp(4) 		produces the result if the input was [0 1 2 3 4]
				2:	dp(2, 4) 	produces the result if the input was [2 3 4]

				There may be 1 or more indexes used as would be described within the question.

			Explicit Constraints:

				Usually provided in the question:

					"you are only allowed to complete k transactions"
					"you are allowed to break up to k obstacles"
					"true if currently holding a key, false if not"
					"currently holding k packages"

			Logs/Tracers

				Anything which is used to keep track of items 'used' or 'visited' e.g. a bitmask whose individual bits are used to keep track of progress.

	Recurrence Relation:

		Recurrence relation is an equation/algorithm.
		Recurrence relation is the relation that exists between states.
		Recurrence relation is the relation that needs to be applied in order to derive the next state (or what/how the value/result of previous states need to be combined/constructed/arranged in order to produce the value/result of the current state).

			dp(i) = dp(i-1) + dp(i-2)

			Here,

				i:	State variable
				dp(i):	The value/result of the question when applied to state i is the combined value of the previous x2 states.

			This is the fibonacci derivation where the value/result of fib(50) = fib(49) + fib(48) i.e. the value/result of state 50 is the combined value/result of state 49 and 48.

		Recurrence relation is the relation that needs to be continually applied in order to find the value/result for the initial input.
		Recurrence relation is used within both Top-Down or Bottom-Up.
		Recurrence relation is typically the most difficult part of finding the solution to DP.
		Recurrence relation is derived generally as follows:

			1. Think around the general state i (which would be between the base case and the initial input).
			2. Attempt to decipher how one would produce the value/result of state i from the previous value/results e.g. i-1, i-2, i-n.
			3. What are the options that can be applied/deployed at each state?

				Fibonacci:	State i is derived from the sum of the previous two states:

							dp(i) = dp(i-1) + dp(i-2)

				House Robber:	State i is derived from whatever is the greatest:

							'What am I able to do in this state, what are the general decisions that I am able to apply and what are the outcomes of those decisons'
							'What would be the value/result of this state given all of the options I have available that would have equally applicable to previous states'
						
							Decision				Value/Result (of this state)			Reason
							---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
							1. Rob the current house		dp(i-2) + Amount in this house i		In order to be able to rob the current house I must have robbed the previous house, therefore I can only have dp(i-2) money in my pocket plus whatever I rob from the current house
							2. Not rob the current house		dp(i-1)						I will not rob this house therefore I will only have in my pocket what I acquired from the previous house dp(i-1) 

							dp(i) = max(dp(i-1), dp(i-2) + Amount in this house i)

		Recurrence relation is/can be derived directly from the base cases:

			1. Consider the Base Case(s) then attempt to decipher/discern the next immediate case, given that this may be perceptible and testable:

				Base Case:			dp(0) = 1
								dp(1) = 1

				Next Immediate Case:		dp(2) = 2

			2. It is clear to see that the next immediate case is the addition of the previous x2 base cases, therefore:

				dp(2) = dp(1) + dp(0)

			3. Therefore in general form:

				dp(i) = dp(i-1) + dp(i-2)

			NB: Deriving the recurrence relation from the base cases to the next immediate case may be the easiest means.

		Recurrence Relation may be:

			Static:		Does not include iteration.
			Non-Static:	Does include iteration.

		Recurrence Relation may at times reveal means to reduce the space complexity when used in Bottom-Up e.g.

			- Recurrence Relation only uses a fixed range of previous results rather than the whole Results array, enabling a large amount of the need to store all values to be discarded e.g.
			- Recurrence Relation of Fibnoacci only needs to use the last x2 elements, it is not required to store all presvious results:

				Result(i) = dp(i-1) + dp(i-2) 

				Therefore it is not necessary to store, say, all x100 previous results but the last x2, therefore Space Complexity goes from O(n) to O(1).			
 
	Base Cases:

		Base case is the most trival/smallest input.
		Base case is a state whose value/result can normally be solved 'by hand', is self-evident or axiomatic.
		Base case is used to stop the recursion.
		Base case is normally the easiest part of DP.
		Base case is found by asking:

			'What is the smallest/most triva/easiest input that there is that I could solve myself without DP'

			Fibonacci:	dp(1) = 1
					dp(2) = 1

			House Robber:	dp(0) = Amount in house	(when there is only x1 house)
					dp(1) = max(House 1 or House 2)

		Base case can be derived by assessing the number of decisons I have per state e.g. if at each state I am able to move forward 1 or 2 steps then there are x2 base cases (for these are the smallest non-trivial environments) 

	dp():

		dp() is the main function which is recursively called to derived the value/result of the initial input.
		dp() contains the recurrence relation.
		dp() input(s) are state variables.
		dp() returns the value/result of the environment for that state as represented by state variables. 

			dp(i):		Returns the value/result for the state i

			dp(1):		Return 1
			dp(2):		Return 1
			dp(3):		Return 2
			dp(4):		Return 3
			...
			dp(n):		Return dp(n-1) + dp(n-2)

	dp[]:

		dp[] is the array within Bottom-Up which is used to perform iterative calculations (via the recurrence relation) to find the value/result of the initial input
		dp[] will contain the value/result of the individual states, where the state represents index:

			dp[0] = 0
			dp[1] = 1
			dp[2] = 1
			dp[3] = 2
			dp[4] = 3
			...
			dp[n] = dp[n-1] + dp[n-2]

	Value/Result:

		Value/Result of a state is the optimal solution for that state.
		Value/Result of a state is the optimal solution if that state was of the value of the initial input being asked by the question.
		Value/Result is either:

			Base Case:	Axiomatic value derived manually
			Constructued:	Constructed/combined from previous states

			NB: There is only value/result for each state.

		Value/Result is the value returned by dp().
		Value/Result is the value stored in the elements of dp[].

	Call Tree:

		Call Tree Root will always be arranged as follows:

					       Root
					________|_______
				____________ 	    ________________
			   ________	________ ________	________
			 Base    Base Base    Base    Base    Base    Base

		Call Tree Root is always the following:

			1. Initial Input
			2. Cover/span the whole context
			3. Represent the result to the whole question

				1D:	context[0]
				2D:	context[0,0] where [row, col]

		Base Case 

			1. Smallest, most trivial, axiomatic value
			2. Cover/span the smallest amount of the context

				1D:	context[n-1]
				2D:	context[n-1, m-1]

		Therefore it should be noted that calculating the results only begins once reached the first base case (opposed to 'on the way down'). Result of each respective node is calculated 'on the way up'.

	Dimensions:

		Dimension correspond to the number of state variables a question has:

			Dimensions = Number of State Variables

		Dimensions of 1, typically displayed as an array:
			 _ _ _ _ _ _ _
			|_|_|_|_|_|_|_|

			- Inputs to each recursive call: 	i			Index within 1D context (an array)

		Dimensions of 2, typically displayed as a grid:
			 _ _ _ _ _ _ _
			|_|_|_|_|_|_|_|
			|_|_|_|_|_|_|_|
			|_|_|_|_|_|_|_|
			|_|_|_|_|_|_|_|

			- Inputs to each recursive call: 	i, j or [iRow, iCol]	Index within 2D context	(a grid)

		The above approach should be employed when trying to visualise the behaviour of the question

	2D DP:

		- 2D DP is the same as 1D, except for the following:

			Question:		Question contains and references x2 inputs which constitute the overall environment of the problem.

							(Number of Inputs = Number of State Variables = Number of Dimensions)

			Top-Down:		Top-Down recursive method contains x2 inputs.

			Bottom-Up:		Bottom-Up contains a 2D array (grid) rather than a 1D array.

			Recurrence Relation: 	Recurrence Relation needs to accommodate the 2 inputs.
						Recurrence Relation needs to consider how the 2 inputs incrementally increase from the base cases to the initial inputs.
						Recurrence Relation needs to decipher how results from smaller inputs combine to produce the result of larger inputs.
						Recurrence Relation may be best (more easily) deciphered in the grid than by other means.
						Recurrence Relation may still be deciphered 

		- 2D DP has the same familarities as 1D:

			Recurrence Relation needs to be deciphered just the same, this may be best done by simply examining the behaviour of the state variables and the generated results in the 2D Grid.

		- 2D Grid:

			 a t g c a t g		[Input 1]
			 _ _ _ _ _ _ _
		      t	|_|_|_|_|_|_|_|
		      g	|_|_|_|_|_|_|_|
		      a	|_|_|_|_|_|_|_|
		      c	|_|_|_|_|_|_|_|

		      [Input 2]

				- Both inputs are represented as row/col, the value in each square is the result for the corresponding input sizes (as read from left-right top-bottom).
				- Therefore the value of each square is the result of having the question applied to the corresponding inputs.
				- Base case is the bottom-right hand corner i.e. the smallest input when:

					Input 1: g
					Input 2: c

					These results can be derived axiomatically.

				- Each square in grid corresponds to the particular input combination e.g.

					[1, 3] is the result when:

						Input 1:	catg
						Input 2:	gac

				- Squares out of bounds may be convenient to use when deciphering the recurrence relation, they represent when the input is empty.

	Standard Approach 1: Framework

		1. Assess and identify:

			Ultimately it is necessary to assess, identify and pull out the following aspects/components, typically done by drawing out the problem:

				1. Context:

					- What is the overall context (or environment) of the question being asked?
					- What does the overall context consist of?

				2. State Variables:

					- What are the state variables of this context?
					- What are the 'things' or aspects which are liable to change over time?
					- What are the 'things' or aspects which would constitute or represent an alternate overall state of the context?
					- How many state variables are there therefore how many dimension are there?

				3. State Transitions:

					- What are the decisions or pathways that are available from one state to the next?
					- How are the input variables changed between states.

				4. Call Tree:

					- Call tree should be drawn out to identify how the Final Result of the Initial Input will ultimately be constructed and found.

						Base Cases:		Help identify base cases
						Initial Input:		Help identify the Initial Input
						State Transitions:	Help identify how the context may transition between states
						Final Result:		Help identify how the Final Result is constructued from the optimal result of the subproblems of smaller inputs
						Sub-problems:		Help identify how the sub-problems exist and overlap
						Decisions:		Help identify the decisions that are available between states, the decisions which ultimately determine what states there are.

				5. Decisions:

					- What are the standard and consistent set of decisions that can be applied at each stage/state to enable to derivation of other states?

				6. Base Cases:

					- What are the base cases?
					- What are the smallest input that can be found given this context?
					- What are the smallest input that can be determined intuitively, self-evident or axiomatic?
					- Are there one or more?
					- Are there any invalid cases which need to be ignored?

				7. Subproblems:

					- What are the sub-problems?
					- What are the optimum results of the sub-problems?
					- How to these results combine to produce the optimum result of the next (slightly larger input)?
					- How to these results combine to produce the optimum result for the initial input?
					- Do the sub-problems i.e. the same question being asked of smaller inputs always yield the same/fixed optimal result. 

				8. Insights:

					- Assess the problem and ask 'what can we say about this problem/question/situation'
					- Try to derive insights into how this situation evolves which may help in the derivation of the Recurrence Relation.

				9. Recurrence Relation:

					- Ultimately all of the above is to derive the Recurrence Relation.
					- What are the options/decisions that are there available to mutate the inputs at each state?
					- What is the relation between individual states?
					- How do the inputs change overtime?
					- How do the inputs and their own results combine to find the result of the next larger input?
					- How do the results in the call tree get combined to find the result for the parent node?
					- How do you build the result of state i from the result of previous smaller inputs

						NB: It is only possible to build/find/calculate the result of a current state from the result of previous smaller states.

					- Ensure that the recurrence relation wholley conforms with the question being asked and the options/behaviour available at each state.

				10. Array/Grid:

					- If necessary draw out an array or grid to help discern and test your hypothesis on how the final result for the initial input is derived via the Recurrence Relation.
					- If necessary:

						1. Choose a relatively small (medium size case) but not base case example which can all be solved axiomatically e.g.

							Longest Common Subsequence:

									a	c	e
								   ----------------------
								a |	3	2	1
								b |	2	2	1
								c |	2	2	1
								d |	1	1	1
								e |	1	1	1

						2. Apply the question to each of the inputs sizes to have the relationship between states emerge:

							- If the first letter match then:	Result = Diagonally down right + 1
							- If the first letter not match then:	Result = Max(Result(Below) , Result(Right))

						3. Thereby creating the Recurrence Relation:

							if(s1[0] == s2[0])	Result[iRow, iCol] = Result[iRow + 1, iCol + 1] + 1
							else			Result[iRow, iCol] = Math.max(dp(iRow + 1, iCol), dp(iRow, iCol + 1))

					- This method/exercise of creating and manually populating/calculating the result array/grid of a managable range of input(s) is incredibly powerful in finding:

						- Insights
						- Behaviour between states
						- State Transition:
							How the results of the incrementally larger (overlapping) states are derived.
						- Ultimately the Recurrence Relation

					- Dare I say this is the only way to derive the Recurrence Relation.

		4. Once all of the above has been discerned apply to standard forms below:

			Top-Down:

				class FindDPSolution
				{
    				    HashMap memo
    				    Environment en
    
    				    private int dp(Input)					//Input = State (return type may be any type e.g. int/String)
				    {
				    	if(Input == Base Case)					//Base Case
					    return Axoimatic result for base case

					int Value/Result = Recurrence Relation			//Value/Result for this state which normally contains recursive calls passing smaller inputs

					if(!memo.containsKey(Input))
            				    memo.put(Input, Value/Result);

        				return memo.get(Input);
    				    }
    
    				    public int findDPSolution(Environment en, Initial Input)
				    {
        				this.en = en;
        				return dp(Initial Input);				//Find and return the Value/Result for the state as represented by the initial input
    				    }
				}

				Here:

					1. Given that the Recurrence Relation is built up of smaller inputs (ultimately working towards to base case).
					2. Execution will traverse down the left hand side of the call tree.
					3. Eventually reaching the left most collection of a single or ultiple base cases.
					4. The first 'rebound' will occur when all of the recursive calls in the recurrence relation are all base cases.
					5. At which point the next immediate parent will be the first to have its result set in the memo.
					6. Traversal will continue a 'pruned' call tree depending on how/when results are stored in memo.
					7. Eventually return to and calculate the result for the initial input.

			Bottom-Up:

				class FindDPSolution
				{    
    				    public int findDPSolution(Environment en, Initial Input)
				    {
					Array[] dp = new Array(Initial Input.length)		//dp[] contains the value/results of all the intermittent states up to initial input

					dp[0] = Axiomatic Value					//Base case axoimatic values placed directly into value/results array

					for(i = Base Case + 1 -> Initial Input)
        				    dp[i] = Recurrence Relation				//Populate the value/results array

					return dp[Initial Input]				//Find and return the Value/Result for the state as represented by the initial input
    				    }
				}

				Here:

					1. The behaviour is ultimately the same as Top-Down except that the Result of each input is stored in the array directly (rather than the memo)
					2. The results are gradually built up until reach the last element in the 'results' array which represents the initial input.

		5. How to find the Recurrence Relation:

			[Return Type] Result = dp[Smaller Values] ...

			Left Hand Side:

				Return Type:

					- The Return Type is:

						1. Ultimate Question:		The Type of the ultimate question being asked.
						2. Subproblems:			The Type of all of the subproblems being asked.
						3. Map Values:			The Type of the Value Column in Memo Map.
						4. Child Nodes:			The Type of the node values as illustrated in the derived Call Tree.

			Right Hand Side:

				The structure of the right hand side of the Recurrence Relation is derived from the Call Tree:

					- Use the visible relationship between the parent node and all of the child nodes as derived from within the Call Tree in accordance and while taking consideration of the question being asked.
					- Therefore

						1. Draw out the initial call tree from the root manually on paper and the expected child nodes.
						2. Determine how the result of the child nodes corresponds/produces the result of the parent/root node.

				For Example:

					'Find the minimum number of coins to make up a target value, e.g. Coins [1, 2, 5], Target 11'

						This can be solved using dynamic programming given that:

							'The optimum result of the subproblems/subvalues of Target can be used to build up and find the optimum result of the ultimate Target value (11)'

						1. Return Type:

							- The Return Type is an Int because the ultimate question is after an Int value.
							- Therefore the Memo Value column is an Int.

						2. Base Cases:

							- What are the base cases/axiomatic examples, this must be derived from good ol' fashion human reasoning of the question:

								Memo[1, 1]	//If Target = 1, then can only be made up of x1 coin
								Memo[2, 1]	//If Target = 2, then can only be made up of x1 coin
								Memo[5, 1]	//If Target = 5, then can only be made up of x1 coin

						3. Call Tree:

							The 'top' can be manually derived:

										11
									--------|--------
									|	|	|
									10	9	6

							Here:

								- The target is subtracted by the individual coin values [1, 2, 5] to produce the child nodes.
								- The result for the root/parent is the smallest result from/of the child nodes.
								- Therefore the Recurrence Realtion is:

									iResult = Min(dp(Target-Coins[0]), dp(Target-Coins[1]), dp(Target-Coins[2]) ... )

								- Therefore ultimately the section of code in the standard form for a Dynamic Programming question must perform the above (hopefully in the most concise way possible).

	Standard Approach 3:

		1. Criteria:	Does the question appear to be solvable via DP, does it generally have the following characteristics:

					1. Overlapping Solutions:	Overall solution contains/comprised of overlapping subproblems
					2. Optimal Substructure:	Overall solution is the combined optimal solution of the optimal solution of all subproblems
					3. Optimal Solution:		The question requires finding the optimal solution of something:

										Minimum:	What is the minimum/shortest/smallest value of something...
										Maximum:	What is the maximum/longest/largest value of something
										Total:		How many ways of doing something...
										Possible:	Is it possible to reach a particular state of the input environment...

					4. Decision Making:		Is there any dynamic decision making involved in order to achieve the overall solution i.e. is it necessary to factor in previous results:

										No:		Greedy
										Yes:		Dynamic Programming

				 					Hence the name 'Dynamic Programming' where the input/algorithm/decision making is dynamic rather than static/constant.

					NB: These are general guidelines which should be applied in accordance with ones own judgement

		2. Mapping:	If so, then it is necessary to break apart the question and map it into the following components by:

						- Assessing the question
						- Extracting/confirming assumptions
						- Identifying the components
						- Ultimately building the correct call tree in order to buildin the source code and achieve the overall solution.

			Rules:			What are all of the 'rules' of this particular environment/situation, what can I and can't do.
						Having absolute clear understanding of these rules enables for the algorithm to emerge.

			Insights:		Carefully assess the question, carefully identify and pull out and write down all specific or subtle insights being presented.
						Carefully craft questions to elict all insights can from interviewer.

			Overlap:		What are the overlapping aspects, what are the aspects whose optimal solutions combine to provide the optimal solution for the initial input.

			Base Case:		What therefore derived from the overlap are the most trivial/smallest/axiomatic base cases.  Allow these base cases to be the foundation to the construction of the call tree.

			Initial Input:		What is the initial input?
						
							Value:		Are we building up from the base cases until we are able to solve for a particular input?
									Where the root of the call tree would naturally be that input of interest?
									Where memoisation would naturally be used to store repeated calculations?

							Empty:		Are we starting with an empty input e.g. 0 or an empty array?
									Where the root of the call tree is that empty structure?
									Where the base cases are the overall solutions we are trying to find?

							State:		A situation may have a fixed number of states, where the base cases are the smallest most trivial state whose solution is self-evident and it is desired to find a more complicated state

			Input Pass Down:	What gets passed down as input to the next recursive call?

			Mutators:		What are the mutators that need to be continually applied to the input?
						What are the 'legs' or 'edges' of the call tree?
						
			Nodes:			What will be returned from the call nodes either via direct calculation or cache?
						Nodes within a call tree produced from dynamic programming do not 'store' anything unlike a graph node, they only return a value/result, a calculation given their input.

			Cases:			What are the base cases?

							Base Case:	The smallest input which is part of the initial input which can be solved axiomatically or through self-evident reasoning
									This result is then used to form the foundation to being able to build up to the overall solution.

						What are the invalid cases?
						What are the ongoing cases?
						How many base cases need to be found: 1 | Some | All?
						The base/invalid/ongoing cases can all often be found from the description of the question or logical/axiomatic reasoning.

			Level:			Does the level/depth of recusion need to be known?

			Path:			Does a list of the mutations applied to reach the base case need to be known?

			Return Type:		Does the rm() need to return a value?

			Internal/External:	Does the input need to be passed down through the call tree or can be referenced via a variable declared external to rm()?

			Bottom Up/Top Down:	Memoisation or Tabulation

			Typical Questions:	Does the problem only have x1 base/invalid case?
						Does the base case exist?
						Does the initial input form a combination of the mutator elements?
						Process/mutate an external data structure?

		3. Program:	Construct program as required.

			Call Tree:		Always start with the call tree, this is your guide to the overall operation of the program.
						Illustrate how the overall solution will be found utilising all of the components above e.g.

							Initial Input -> Base Case

								1. Additive:		0/Empty 	-> 	Target Value
								2. Subtractive:		Target Value	->	0/Empty

							Invalid Case
							Ongoing Case

							Result Set:

								1. Nodes/Inputs?
								2. Base Case Paths?

			Source Code:		Produce source in adherence to the call tree.

			dp()			The dp() function is the core function which is the engine to solving and finding the overall solution:

							

			Optimisation:		Apply necessary optimisation techniques:

							Memoisation:		Can any aspects of the overall calculation be stored/retrieved from within a hashmap rather than repeat identical calculation. 
							Removal:		Can any values be removed during the calculation process?
							Ignored:		Can any values be ignored during the calculation process?

		

	Example: Climbing Stairs:

		Q: Given the array Cost which represents the cost per step on a flight of stairs, starting from step [0] or [1] what is the minimum cost to reach top if only allowed to take 1 or 2 steps at time?

			Cost[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]

		Standard Approach 1: Framework

			1. Assess Question
			2. Identify:

				Environment:		1D Array (Cost)
				States:			0 - (Cost.length-1)
				State Variables:	Index
				Base Case:		A staircase of 1 step, which would be simply Cost[0]
				Invalid Case:		Index < 0

			3. Derive Recurrence Relation via asking:

				Decisions/options available at each state:		Move forward 1 or 2 steps
				How do you construct the value/result at state i:	Current cost + whatever is greater dp(i-1) or dp(i-2)

			4. Call Tree:

													dp(4)
								---------------------------------------------------------------------------------------------
								dp(3)											dp(2)
							-------------------------------------
							dp(2)				dp(1)
						---------------------		----------------------
						dp(1)		dp(0)		dp(0)		dp(-1)
					----------------------
					dp(0)		dp(-1)

				Call Tree is as above where it would proceed up to dp(9).
				Call Tree is read as follows:

					dp(1) value/result = cost[1] + d(0) only
					dp(4) value/result = cost[4] + Min(d(3) value/result || d(2) value/result))

				Operation of the program does a complete traversal of the whole call tree via DFS where either all the way down to all base cases or just as far to those states already saved in memo. 

			5. Source Code:

				Top-Down:	The function dp() starts with the initial input of (Cost.length - 1)
						The function dp() builds the entire call tree above, ultimately so that it can find the value/result of dp(8) and dp(7) so that they can be combined to find the value/result of dp(9). 


			6. dp():

				dp(0) represents and finds the value/result of an environment only contain element 0:		Cost[1]
				dp(1) represents and finds the value/result of an environment only contain element 0 -> 1:	Cost[1, 100]
				dp(2) represents and finds the value/result of an environment only contain element 0 -> 2:	Cost[1, 100, 1]
				dp(9) represents and finds the value/result of an environment containing all elements 

			7. Program Operation:

				Program does a complete traversal of the call tree.
				Program stops at any inputs which have already been calculated and therefore in the memo (including the base cases which are already manually entered into the memo).
				Program needs to complete (an effective) traversal of the whole call tree in order to find the value/result of the child call node of the initial input in order to find the value/result of the initial input.

	Example: Maximum Score from Performing Multiplication Operations (1770):

		nums = [1 2 3]		multipliers = [3 2 1]

		Standard Approach 1: Framework

			1. Assess Question
			2. Identify:

				Environment:		1D Array (nums)		(multipliers are not the environment, they form part of the decision making that are applied to the environment) 
				States:			0 - (nums.length-1)
				State Variables:	Index
							Start | End
				Base Case:		nums is of size 1, which would return nums[0] * multipliers[i]

			3. Derive Recurrence Relation via asking:

				Decisions/options available at each state:		Get first or last from nums and mutltiply by multipliers[i]
				How do you construct the value/result at state i:	Whatever is greater dp(start) or dp(end)

					int iResult/Value = 

	Example: 2D Longest Common Subsequence

		Q: How many ways is it possible to climb N number of stairs if able to take either 1 or 2 steps:

			1. Identify items:

				Initial Input:		N
				Mutators:		-1 and -2
				Base Case:		Recursive Input = 0
				Invalid Case:		Recursive Input < 0
				Ongoing Case:		Recursive Input > 0
				Level:			Not Needed
				Path:			Not Needed
				Return Type:		Not Needed
				Internal/External:	Internal but with external counter

			2. Answer:		How many base cases are there?
			3. Memoisation:		Applicable?

		Psuedo Code:

			Place base cases into HashMap
			
			return int findSolution(input)
			{
			    if(Memo contains input)
				return value

			    Add to memo(input, value which would correspond to an input value of input)

			    return memo value for input
			}

	

	Recursion:

		- Recursion can be deployed within many areas, including:

			1. Dynamic Programming.
			2. Graph Traversal.
			3. Back Tracking

		- Recursion within dynamic programming and graph traversal are fundamentally equivalent:

			Dynamic Programming		Graph Traversal
			_________________________________________________________________________________________________________________________________________________

			Initial input			Starting node
			Input				Current node
			Base case			Target node
			Invalid case			Unavilable node 		e.g. a blocked 'walled' node
			Mutators			Paths to adjacent nodes 	e.g. the available means/options of traversing and arriving at the adjacent nodes
			Mutation			Moving to an adjacent node
			Parent rm() call		Previous node
			Child rm() call			Adjacent/next node

	Call Tree:

		- Call tree is not an existing graph/structure in memory.
		- Call tree nodes:

			- Nodes are not physical constructs in memory.
			- Nodes do not hold any value.
			- Nodes only hold the mutated input value from previous recursive method call.
			- Nodes are emphemeral recursive method calls which are essentially just a memory address.

		- Call tree represents temporal instances of rm() on the call stack.
		- Call tree is generated 'on the fly' and respresents the recursive method calls and the mutated input being passed down, each rm() call has x3 possible outcomes/cases:

			1. Base:	Recursion ceases, the design of the rm() determines behaviour once base case found, there are x3 options:

						Base Cases		Return to Root
						________________________________________________________________________________________________________________________________________________________________

						Find x1			Immediate 			Once x1 base case has been found immediately return to the root and the initial method.
						Find n 			Non-Immediate			Traverse the partial tree, once n base cases found then return to the root and the initial method.
						Find all		Non-Immediate			Traverse the whole tree, once all base cases found then return to the root and the initial method.

					There may be multiple definitions of base case:

						if(input == 1 || input%10 == 5 || ...)
							return 

			3. Ongoing:	Recursion continues passing mutated input, number of branches may be:

						Number of		Tree
						Branches		Shape
						________________________________________________________________________________________________________________________________________________________________

						1:			Degenerate:			A straight line down from the root node until the single base case is reached.
						Fixed			Tree (Symmetric):		A tree where each recursive method generates the fixed same number of child rm() calls.
						Varied:			Tree (Non-Symmetric):		A tree where each recursive method generates differing number of child rm() calls, The condition is passed down as an argument with each rc(...) call.

														void rc(input, condition)
														{
															if(baseCase == input)
																return

															for(i = 0 -> n && condition)
																[return] rc(modifiedInput_i)

															postProcessing
														}

			2. Invalid:	Recursion ceases, control immediately returns to parent rm().

	Recursive Method Structure

		[return type] rm(input, mutator, iLevel, condition)
		{
			[Base Case]
				if(input == baseCase1 || input == baseCaseN || ...)
					return/process [base value]

			[Invalid Case]
				if(input == inValid)
					return

			[Ongoing Case]
				[recursive return] rm(modifiedInput_1)					//Individual (non-loopable mutations)
				[recursive return] rm(modifiedInput_2)			
				[recursive return] rm(modifiedInput_n)

				(OR)

				for(i = 0 -> mutator.n && modifiedInput_i == valid)
					[recursive return] rm(modifiedInput_i)

				(OR)

				for(i = 0 -> mutator.n && modifiedInput_i == valid)			//Level/depth tracking
					[recursive return] rm(modifiedInput_i, iLevel+1)

				(OR)

				for(i = 0 -> mutator.n && modifiedInput_i == valid && condition)	//Conditional rm() calls
					[recursive return] rm(modifiedInput_i, condition))

				(OR)

				for(i = 0 -> mutator.n && modifiedInput_i == valid)			//Path tracking
				{
					alPath.add(i)
					[recursive return] rm(modifiedInput_i)
					alPath.remove(alPath.size-1)
				}

			[postProcessing]

			[return]
		}

		[return type]

			[return type]		Behaviour/Use
			_______________________________________________________________________________________________________

			void:			Traverse whole call tree processing a mutated input or external data structure
			boolean:		Traverse whole call tree and determine if any base case exists in the call tree
			type:			Traverse whole call tree return the nth [base value] found

			Behaviour/Use depends on whether [recursive return] has been include

			[recursive returns]	Behaviour
			______________________________________________________________________

			Included:		Return the [base value] in the first base case
			Not Included:		Return the [base value] in the last base case

		[input]

			- Input is the unique for each rm() call.
			- Input is mutated within the rm() and passed onto 'its own' recursive rm() calls.
			- Input is continually reduced until reach base case (at which point return to previous rm() call).

		[initial input]

			- Input that is provided from the initial method would be the initial (large) input that needs to be processed in order to find the desired solutions.

		[valid input]

			- Valid input can be determined either:

				Prior:

					void rm(input)
					{
						if(input == baseCase)
							process/log
							return

						if(modifiedInput == valid)			//The modified input is checked 'prior' to being passed into another instance of rm().
							return rm(modifiedInput)
					}

				Within:

					void rm(input)
					{
						if(input == baseCase)
							return

						if(input == invalidCase)			//The modified input is checked 'within' its own instance of rm()
							return
					}

				[recursive return]	Form			
				__________________________________________________________________________________________________________________________________________________________________________________________________________

				Used			Prior Only		Prior must be used if [recursive return] is used. This is to prevent execution immediately returning to root/initial method when an invalid case is found.
				Not Used		Prior | Within		Prior or Within can be used if [recursive return] is not used.

			NB: Invalid Modified Input and [recursive return]

				- If it is possible for invalid modified inputs to emerge, then [recursive return] can not be used for it is possible for an:

					rm() to incorrectly behave as if a base case as been found.
					rm() will naturally return rather than on-going to find further base cases.
					rm() will return immediately to root/initial method.

		[mutator]:

			- Mutator is the consistent set of mutations which are applied to the input of each rm() call.
			- Mutator may reside external to the rm() calls or 'passed down' each rm() call.
			- Mutator is typically a set/array of values that are applied to the input.
			- Mutator values are what form the path and particular combinations that result in a base case and are typically the sought answer to dynamic programming.
			- Mutation may be an additive or subtractive process:

				Additive: Initial input is empty or 0 and subsequent values are 'added' to reach a target value:

					Initial Input:		[]					0
					Mutator:		[] + [1]				0 + 1
								[] + [2]...				0 + 2...

					Base Case:		[1,2,6,10] (All Valid Elements)		10 (Target Value)

				Subtractive: Initial input is a value and subsequent values are 'subtracted' to reach 0 or empty:

					Initial Input:		[1,2,6,10]				10
					Mutator:		[1,2,6,10] - [1]			10 - 1
									[1,2,6,10] - [2]...			10 - 2...

					Base Case:		[] (Empty)				0

		[modifiedInput_i]:

			- All internal ongoing rm() calls must contain a unique modified version of the input.

		[recursive return]:

			Used:		[recursive return] is only used when all x3 below are true:

						1. No Invalid Modified Input:		No invalid case will ever be produced. Only events which cause return to the parent rm() is when a base case has been found or all rm()'s have returned.
						2. x1 Base Case:			Only x1 (1st) base case needs to be found and then immediately return to the root/initial method.
						3. Call Tree:				Call tree does not need to be fully traversed only via the standard sequence (below) until 1st base case is found.

			Not Used:	[recursive return] is not used when need to do any of the below:

						1. Invalid Modified Inputs:		Invalid modified inputs can emerge.
						2. Multiple Base Case:			Multiple/all base cases need to be found.
						3. Call Tree:				Call tree needs to be fully traversed.
						4. Backtracking:			Backtracking needs to explore the whole potential call tree.
											Backtracking may encounter invalid cases which need to be ignored (and 'backtracked') rather than cause an immediate return to root/initial method.

						NB: It is fair to say that the majority of DP problem will NOT use [recursive return].

			[recursive return]	Behaviour
			_________________________________________________________________________________________________________________________________________

			Included:		Return to root		Return immediately to the root/initial method upon finding first base case
			Not Included:					Return to root/initial method naturally once whole call tree has been generated/traversed

			Included:		Back Tracking		Back tracking not possible given that the first invalid case will cause recursion call stack to cease and return back to the root/initial method.
			Not Included:					Back tracking is possible.

			Included:		[postProcessing]	Does not run any statements after the rm() call, any [postProcessing] or other rm() calls are inaccessible 
			Not Included:					Does run statements after the rm() call, any [postProcessing] or other rm() calls are accessible and ran

			Included:		Base Cases		x1 base case (maximum):		Only x1 and the first base case is found and returned to root/initial method  
			Not Included:					All base cases:			All base cases are found and nothing is returned to the root/initial method

			[recursive returns] may be applied to all, some or no rm()'s:

				1. All:

					- All rm() [recursively return]:

						for(i = 0 -> n)
							return rm(modifiedInput_i)

						[postProcessing]

						Behaviour:

							1. First base case found.
							2. Execution returns immediately to the root/initial method.
							3. Nothing else will ever execute after the rm() call one the base case has been found

							[postProcessing] will never run and always inaccessible.

				2. Partial:

					- Partial rm() [recursively return]:

						return rm(modifiedInput_1)
						rm(modifiedInput_2)
						return rm(modifiedInput_3)

						[postProcessing]

						Behaviour:

							1. Upon traversing back up the call tree, program execution will depend on whether the individual parental rm() calls in the parental chain [recursively returned] or not.
							2. If execution traverses back up the call tree due to base case, the next program execution depends on whether that particular parent rm() call [recursively returns]:

								Parent rm()
								[Recursively Return]	Behaviour
								___________________________________________________________________________________________________________________________________________________________________________________________

								Y			Execution will immediately return to its immediate parent rm() call.
								N			Execution will continue with any statements after that particular rm() call (including other rms() calls, which may send execution down the call tree again).

							3. If execution traverses back up the call tree due to base case:

								Parent rm()
								[Recursively Return]	Behaviour
								______________________________________________________________________________________________________________________________________________________________________________

								All:			If all parent rm() call's [recursively return] then execution will immediately return to the root/initial method.
								Partial:		If a particular parent rm() call does not [recursive return] then any statements (including other rm() calls) after that particulr rm() call will run. 

							[postProcessing] will never run given that the last rm() call [recursively returns] therefore execution will never get past this point in all circumstances.

				3. None:

					- No rm() [recursively return]:

						for(i = 0 -> n)
							rm(modifiedInput_i)

						[postProcessing]

						Behaviour:

							1. Whole call tree will reproduced and traversed in all circumstances.
							2. Return to the root/initial method only occurs 'naturally'

							[postProcessing] will always run.

			[postProcessing]

				- postProcessing is run when returning 'up a level' to the parent rm() or to the 'lower' rm() call on the call stack.
				- postProcessing is run when there is no [recursive return] on any immediate subsequent rm() call.

			Natural Return:

				- The 'natural' return is the return when a method naturally ends.
				- The 'natural' return when applied to last statement has the following equivalences:

					rc()							rc()							rc()
					{							{							{
						...							...							...
						return rc(...)			=			rc(...)				=			rc(...)
					}							}								return
																				}
			Other Forms:

				- There are of course other structrual arrangements/forms which are ultimately the same as above e.g.

					void rm(input)
					{
						[preProcess: modifiedInput]

						if (input = baseCase)	process/return;
						else 			return rm(modifiedInput)

						[postProcess]	//Unreachable
					}

	Call Tree Sequence:

		- Call tree sequence is always consistent in dynamic programming as shown, given that it is not an existing structure but a consequence of continual rm() calls. 

											1
					_________________________________________________________________________________________________
					2						15						28
			__________________________________		_________________________________		_________________________________
			3		7		11		16		20		24		29		33		37
	    	     _______	      ______	     ________	     ________	     ________	     ________	     ________	     ________	     ________
	     	     4  5  6          8 9 10	     12 13 14	     17 18 19	     21 22 23	     25 26 27	     30 31 32	     34 35 36	     38 39 40

		- Call tree sequence can not be determined by the structure of the rm() as in Graphs.
		- Call tree sequence can not be determined by any of the following, the following is not applicable to dynamic programming:

			1. PreOrder()
			2. InOrder()
			3. PostOrder()
			4. LevelOrder()
			5. DFT
			6. BFT

		- Call tree sequence may be consistent but it's structure is not. The structure of the call tree is of course dependent upon:

			1. Initial Input
			2. Mutators

			For these x2 factors determine when base cases and invalid cases are found and where recursion ('backtracking') occurs and therefore the overall shape of the call tree.

		- Call tree sequence example: Find all bases cases?

			rm(input)
    			{
				if(input == baseCase)
					process/log
					return

        			for(i -> mutator.n)
        			{
					if(modifiedInput_i == valid)
						rm(modifiedInput_i)
        			}
    			}
												rm()
			 _______________________________________________________________________|_______________________________________________________________________________________________
			|						|						|						|			|
			rm()						rm()						rm()						x			rm()
			|_______________________________		|_______________________________		|_______________________________		24			|_______________________________
			|	|	|	|	|		|	|	|	|	|		|	|	|	|	|					|	|	|	|	|
			rm()	x	x	rm()	x		x	x	x	x	x		x	x	x	x	x					x	x	x	x	x
			|	6	7	|	13		14	15	16	17	18		19	20	21	22	23					25	26	27	28	29
			|			|_______________________________
			|			|	|	|	|	|
			|			8	9	10	11	12
			|_______________________________
			|	|	|	|	|
			1	2	3	4	5

	Base Case Existance:

		- Base case existance is where only need to determine if the problem has any solution.
		- Base case existance once found need only return immediately to root and initial method once a single instance of the base case has been found.
		- Base case existance has the following general form:
 
			boolean rm(input)
    			{
				if(input == baseCase)
					return true;

        			for(i -> mutator.n)
        			{
					if(modifiedInput_i == valid)
						if(rm(modifiedInput_i))
							return true
        			}

				return false;
    			}

	Recursive Time/Space Complexity:

		- Time/space complexity of a recursive algorithm is best evaluated from the call tree.

			Time Complexity:

				Associated with the amount of branching:

					1. What is the increase rate in the function calling itself?
					2. What is the worse case scenario for the maximum size of the base of the call tree?

			Space Complexity:

				Associated with the maximum height.

					1. What is the maximum height of the call tree?
					2. What memory does each iteration of rm() use e.g. does it allocate its own memory each time, if so then that must also be taken into consideration.
					3. What is the worse case scenario for the maximum height and memory usage within the call tree?

		- For example, given the fibonacci sequence, the recursive implementation calls itself x2 per iteration:

							fib(7)
					 _______________|_______________
					|				|
			n = 1		fib(5)				fib(6)			Calls: 2
					|_______			|_______
					|	|			|	|
			n = 2		fib(3)	fib(4)			fib(4)	fib(5)		Calls: 4
					|	|			|	|

		- Therefore as shown:

			Time: 	O(2^n)
			Space: 	O(n * m)	m: Memory used by the recursive method (if any)

		- The time/space complexities can be derived by evaluating the source code but if in doubt draw out the call tree.
		- The space complexity is derived from the following x2 facts:

			1. Immediate garbage collection:	Released memory is immediately garbage collected
			2. Maximum depth:			Maximum amount of memory that needs to be used at any one time is:

									(amount of memory used in rm() call * maxmium possible depth of rm() calls in call tree) i.e. when the recursion is at the lowest point/furthest distance from root.

	
