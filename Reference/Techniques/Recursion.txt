Recursion:

	Overview:

		- Recursion can be deployed within many areas, including:

			1. Dynamic Programming.
			2. Graph Traversal.
			3. Back Tracking

		- Recursion within dynamic programming and graph traversal are fundamentally equivalent:

			Dynamic Programming		Graph Traversal
			_________________________________________________________________________________________________________________________________________________

			Initial input			Starting node
			Input				Current node
			Base case			Target node
			Invalid case			Unavilable node 		e.g. a blocked 'walled' node
			Mutators			Paths to adjacent nodes 	e.g. the available means/options of traversing and arriving at the adjacent nodes
			Mutation			Moving to an adjacent node
			Parent rm() call		Previous node
			Child rm() call			Adjacent/next node

	Dynamic Programming

		Overview:

			- Dynamic Programming is a subset of 'Divide and Conquer' technique which involves breaking down an initial problem into a smaller subsets of the same problem but with smaller input values:

				1-D:		Initial input and solution needs to work on a 1-Dimensional array
				2-D:		Initial input and solution needs to work on a 2-Dimensional array
				Top-Down:	Recursion (with Memoisation)
				Bottom-Up:	Tabulation

			- Dynamic Programming is a technique or approach that can be applied to any input e.g.

				1. Array
				2. String
				3. Value

			- Dynamic Programming is not solely applicable to arrays or strings but is a technique that can be applied to any problem that can be broken down into a smaller subset of problems.

		Call Tree:

			- Call tree is not an existing graph/structure in memory.
			- Call tree nodes:

				- Nodes are not physical constructs in memory.
				- Nodes do not hold any value.
				- Nodes only hold the mutated input value from previous recursive method call.
				- Nodes are emphemeral recursive method calls which are essentially just a memory address.

			- Call tree represents temporal instances of rm() on the call stack.
			- Call tree is generated 'on the fly' and respresents the recursive method calls and the mutated input being passed down, each rm() call has x3 possible outcomes/cases:

				1. Base:	Recursion ceases, the design of the rm() determines behaviour once base case found, there are x3 options:

							Base Cases		Return to Root
							________________________________________________________________________________________________________________________________________________________________

							Find x1			Immediate 			Once x1 base case has been found immediately return to the root and the initial method.
							Find n 			Non-Immediate			Traverse the partial tree, once n base cases found then return to the root and the initial method.
							Find all		Non-Immediate			Traverse the whole tree, once all base cases found then return to the root and the initial method.

						There may be multiple definitions of base case:

							if(input == 1 || input%10 == 5 || ...)
								return 

				3. Ongoing:	Recursion continues passing mutated input, number of branches may be:

							Number of		Tree
							Branches		Shape
							________________________________________________________________________________________________________________________________________________________________

							1:			Degenerate:			A straight line down from the root node until the single base case is reached.
							Fixed			Tree (Symmetric):		A tree where each recursive method generates the fixed same number of child rm() calls.
							Varied:			Tree (Non-Symmetric):		A tree where each recursive method generates differing number of child rm() calls, The condition is passed down as an argument with each rc(...) call.

															void rc(input, condition)
															{
																if(baseCase == input)
																	return

																for(i = 0 -> n && condition)
																	[return] rc(modifiedInput_i)

																postProcessing
															}

				2. Invalid:	Recursion ceases, control immediately returns to parent rm().

		Recursive Method Structure

			[return type] rm(input, mutator, iLevel, condition)
			{
				[Base Case]
					if(input == baseCase1 || input == baseCaseN || ...)
						return/process [base value]

				[Invalid Case]
					if(input == inValid)
						return

				[Ongoing Case]
					[recursive return] rm(modifiedInput_1)					//Individual (non-loopable mutations)
					[recursive return] rm(modifiedInput_2)			
					[recursive return] rm(modifiedInput_n)

					(OR)

					for(i = 0 -> mutator.n && modifiedInput_i == valid)
						[recursive return] rm(modifiedInput_i)

					(OR)

					for(i = 0 -> mutator.n && modifiedInput_i == valid)			//Level/depth tracking
						[recursive return] rm(modifiedInput_i, iLevel+1)

					(OR)

					for(i = 0 -> mutator.n && modifiedInput_i == valid && condition)	//Conditional rm() calls
						[recursive return] rm(modifiedInput_i, condition))

					(OR)

					for(i = 0 -> mutator.n && modifiedInput_i == valid)			//Path tracking
					{
						alPath.add(i)
						[recursive return] rm(modifiedInput_i)
						alPath.remove(alPath.size-1)
					}

				[postProcessing]

				[return]
			}

			[return type]

				[return type]		Behaviour/Use
				_______________________________________________________________________________________________________

				void:			Traverse whole call tree processing a mutated input or external data structure
				boolean:		Traverse whole call tree and determine if any base case exists in the call tree
				type:			Traverse whole call tree return the nth [base value] found

				Behaviour/Use depends on whether [recursive return] has been include

				[recursive returns]	Behaviour
				______________________________________________________________________

				Included:		Return the [base value] in the first base case
				Not Included:		Return the [base value] in the last base case

			[input]

				- Input is the unique for each rm() call.
				- Input is mutated within the rm() and passed onto 'its own' recursive rm() calls.
				- Input is continually reduced until reach base case (at which point return to previous rm() call).

			[initial input]

				- Input that is provided from the initial method would be the initial (large) input that needs to be processed in order to find the desired solutions.

			[valid input]

				- Valid input can be determined either:

					Prior:

						void rm(input)
						{
							if(input == baseCase)
								process/log
								return

							if(modifiedInput == valid)			//The modified input is checked 'prior' to being passed into another instance of rm().
								return rm(modifiedInput)
						}

					Within:

						void rm(input)
						{
							if(input == baseCase)
								return

							if(input == invalidCase)			//The modified input is checked 'within' its own instance of rm()
								return
						}

					[recursive return]	Form			
					__________________________________________________________________________________________________________________________________________________________________________________________________________

					Used			Prior Only		Prior must be used if [recursive return] is used. This is to prevent execution immediately returning to root/initial method when an invalid case is found.
					Not Used		Prior | Within		Prior or Within can be used if [recursive return] is not used.

				NB: Invalid Modified Input and [recursive return]

					- If it is possible for invalid modified inputs to emerge, then [recursive return] can not be used for it is possible for an:

						rm() to incorrectly behave as if a base case as been found.
						rm() will naturally return rather than on-going to find further base cases.
						rm() will return immediately to root/initial method.

			[mutator]:

				- Mutator is the consistent set of mutations which are applied to the input of each rm() call.
				- Mutator may reside external to the rm() calls or 'passed down' each rm() call.
				- Mutator is typically a set/array of values that are applied to the input.
				- Mutator values are what form the path and particular combinations that result in a base case and are typically the sought answer to dynamic programming.
				- Mutation may be an additive or subtractive process:

					Additive: Initial input is empty or 0 and subsequent values are 'added' to reach a target value:

						Initial Input:		[]					0
						Mutator:		[] + [1]				0 + 1
									[] + [2]...				0 + 2...

						Base Case:		[1,2,6,10] (All Valid Elements)		10 (Target Value)

					Subtractive: Initial input is a value and subsequent values are 'subtracted' to reach 0 or empty:

						Initial Input:		[1,2,6,10]				10
						Mutator:		[1,2,6,10] - [1]			10 - 1
									[1,2,6,10] - [2]...			10 - 2...

						Base Case:		[] (Empty)				0

			[modifiedInput_i]:

				- All internal ongoing rm() calls must contain a unique modified version of the input.

			[recursive return]:

				Used:		[recursive return] is only used when all x3 below are true:

							1. No Invalid Modified Input:		No invalid case will ever be produced. Only events which cause return to the parent rm() is when a base case has been found or all rm()'s have returned.
							2. x1 Base Case:			Only x1 (1st) base case needs to be found and then immediately return to the root/initial method.
							3. Call Tree:				Call tree does not need to be fully traversed only via the standard sequence (below) until 1st base case is found.

				Not Used:	[recursive return] is not used when need to do any of the below:

							1. Invalid Modified Inputs:		Invalid modified inputs can emerge.
							2. Multiple Base Case:			Multiple/all base cases need to be found.
							3. Call Tree:				Call tree needs to be fully traversed.
							4. Backtracking:			Backtracking needs to explore the whole potential call tree.
												Backtracking may encounter invalid cases which need to be ignored (and 'backtracked') rather than cause an immediate return to root/initial method.

							NB: It is fair to say that the majority of DP problem will NOT use [recursive return].

				[recursive return]	Behaviour
				_________________________________________________________________________________________________________________________________________

				Included:		Return to root		Return immediately to the root/initial method upon finding first base case
				Not Included:					Return to root/initial method naturally once whole call tree has been generated/traversed

				Included:		Back Tracking		Back tracking not possible given that the first invalid case will cause recursion call stack to cease and return back to the root/initial method.
				Not Included:					Back tracking is possible.

				Included:		[postProcessing]	Does not run any statements after the rm() call, any [postProcessing] or other rm() calls are inaccessible 
				Not Included:					Does run statements after the rm() call, any [postProcessing] or other rm() calls are accessible and ran

				Included:		Base Cases		x1 base case (maximum):		Only x1 and the first base case is found and returned to root/initial method  
				Not Included:					All base cases:			All base cases are found and nothing is returned to the root/initial method

				[recursive returns] may be applied to all, some or no rm()'s:

					1. All:

						- All rm() [recursively return]:

							for(i = 0 -> n)
								return rm(modifiedInput_i)

							[postProcessing]

							Behaviour:

								1. First base case found.
								2. Execution returns immediately to the root/initial method.
								3. Nothing else will ever execute after the rm() call one the base case has been found

								[postProcessing] will never run and always inaccessible.

					2. Partial:

						- Partial rm() [recursively return]:

							return rm(modifiedInput_1)
							rm(modifiedInput_2)
							return rm(modifiedInput_3)

							[postProcessing]

							Behaviour:

								1. Upon traversing back up the call tree, program execution will depend on whether the individual parental rm() calls in the parental chain [recursively returned] or not.
								2. If execution traverses back up the call tree due to base case, the next program execution depends on whether that particular parent rm() call [recursively returns]:

									Parent rm()
									[Recursively Return]	Behaviour
									___________________________________________________________________________________________________________________________________________________________________________________________

									Y			Execution will immediately return to its immediate parent rm() call.
									N			Execution will continue with any statements after that particular rm() call (including other rms() calls, which may send execution down the call tree again).

								3. If execution traverses back up the call tree due to base case:

									Parent rm()
									[Recursively Return]	Behaviour
									______________________________________________________________________________________________________________________________________________________________________________

									All:			If all parent rm() call's [recursively return] then execution will immediately return to the root/initial method.
									Partial:		If a particular parent rm() call does not [recursive return] then any statements (including other rm() calls) after that particulr rm() call will run. 

								[postProcessing] will never run given that the last rm() call [recursively returns] therefore execution will never get past this point in all circumstances.

					3. None:

						- No rm() [recursively return]:

							for(i = 0 -> n)
								rm(modifiedInput_i)

							[postProcessing]

							Behaviour:

								1. Whole call tree will reproduced and traversed in all circumstances.
								2. Return to the root/initial method only occurs 'naturally'

								[postProcessing] will always run.

				[postProcessing]

					- postProcessing is run when returning 'up a level' to the parent rm() or to the 'lower' rm() call on the call stack.
					- postProcessing is run when there is no [recursive return] on any immediate subsequent rm() call.

				Natural Return:

					- The 'natural' return is the return when a method naturally ends.
					- The 'natural' return when applied to last statement has the following equivalences:

						rc()							rc()							rc()
						{							{							{
							...							...							...
							return rc(...)			=			rc(...)				=			rc(...)
						}							}								return
																				}
				Other Forms:

					- There are of course other structrual arrangements/forms which are ultimately the same as above e.g.

						void rm(input)
						{
							[preProcess: modifiedInput]

							if (input = baseCase)	process/return;
							else 			return rm(modifiedInput)

							[postProcess]	//Unreachable
						}

		Call Tree Sequence:

			- Call tree sequence is always consistent in dynamic programming as shown, given that it is not an existing structure but a consequence of continual rm() calls. 

												1
						_________________________________________________________________________________________________
						2						15						28
				__________________________________		_________________________________		_________________________________
				3		7		11		16		20		24		29		33		37
		     	     _______	      ______	     ________	     ________	     ________	     ________	     ________	     ________	     ________
		     	     4  5  6          8 9 10	     12 13 14	     17 18 19	     21 22 23	     25 26 27	     30 31 32	     34 35 36	     38 39 40

			- Call tree sequence can not be determined by the structure of the rm() as in Graphs.
			- Call tree sequence can not be determined by any of the following, the following is not applicable to dynamic programming:

				1. PreOrder()
				2. InOrder()
				3. PostOrder()
				4. LevelOrder()
				5. DFT
				6. BFT

			- Call tree sequence may be consistent but it's structure is not. The structure of the call tree is of course dependent upon:

				1. Initial Input
				2. Mutators

				For these x2 factors determine when base cases and invalid cases are found and where recursion ('backtracking') occurs and therefore the overall shape of the call tree.

			- Call tree sequence example: Find all bases cases?

				rm(input)
    				{
					if(input == baseCase)
						process/log
						return

        				for(i -> mutator.n)
        				{
						if(modifiedInput_i == valid)
							rm(modifiedInput_i)
        				}
    				}
													rm()
				 _______________________________________________________________________|_______________________________________________________________________________________________
				|						|						|						|			|
				rm()						rm()						rm()						x			rm()
				|_______________________________		|_______________________________		|_______________________________		24			|_______________________________
				|	|	|	|	|		|	|	|	|	|		|	|	|	|	|					|	|	|	|	|
				rm()	x	x	rm()	x		x	x	x	x	x		x	x	x	x	x					x	x	x	x	x
				|	6	7	|	13		14	15	16	17	18		19	20	21	22	23					25	26	27	28	29
				|			|_______________________________
				|			|	|	|	|	|
				|			8	9	10	11	12
				|_______________________________
				|	|	|	|	|
				1	2	3	4	5

		Base Case Existance:

			- Base case existance is where only need to determine if the problem has any solution.
			- Base case existance once found need only return immediately to root and initial method once a single instance of the base case has been found.
			- Base case existance has the following general form:
 
				boolean rm(input)
    				{
					if(input == baseCase)
						return true;

        				for(i -> mutator.n)
        				{
						if(modifiedInput_i == valid)
							if(rm(modifiedInput_i))
								return true
        				}

					return false;
    				}

		Recursive Time/Space Complexity:

			- Time/space complexity of a recursive algorithm is best evaluated from the call tree.

				Time Complexity:

					Associated with the amount of branching:

						1. What is the increase rate in the function calling itself?
						2. What is the worse case scenario for the maximum size of the base of the call tree?

				Space Complexity:

					Associated with the maximum height.

						1. What is the maximum height of the call tree?
						2. What memory does each iteration of rm() use e.g. does it allocate its own memory each time, if so then that must also be taken into consideration.
						3. What is the worse case scenario for the maximum height and memory usage within the call tree?

			- For example, given the fibonacci sequence, the recursive implementation calls itself x2 per iteration:

								fib(7)
						 _______________|_______________
						|				|
				n = 1		fib(5)				fib(6)			Calls: 2
						|_______			|_______
						|	|			|	|
				n = 2		fib(3)	fib(4)			fib(4)	fib(5)		Calls: 4
						|	|			|	|

			- Therefore as shown:

				Time: 	O(2^n)
				Space: 	O(n * m)	m: Memory used by the recursive method (if any)

			- The time/space complexities can be derived by evaluating the source code but if in doubt draw out the call tree.
			- The space complexity is derived from the following x2 facts:

				1. Immediate garbage collection:	Released memory is immediately garbage collected
				2. Maximum depth:			Maximum amount of memory that needs to be used at any one time is:

										(amount of memory used in rm() call * maxmium possible depth of rm() calls in call tree) i.e. when the recursion is at the lowest point/furthest distance from root.

		Path Tracking:

			- Path within the call tree records the inidividual modifications that are applied recursively to the initial input.
			- Path is best stored in a List<> due to the O(1) operations:

				List<Modification_Type> alPath = new ArrayList<>();

				void rc(input)
				{
					if(baseCase == input)
					{
						Print alPath
						return
					}

					for(i = 0 -> n)
					{
						alPath.add(i)
						rc(modifiedInput_i)
						alPath.remove(alPath.size-1)
					}

					postProcessing
				}

				Above will find all base cases in call tree and the corresponding combination which produces that base case.

			- NB: Path Tracking should only be carried out using recursion (not iteration traversal of tree) given that:

				1. Once reach end of branch (leaf node) execution immediately jumps to the next node in stack which maybe a completely different branch many levels back up.
				2. The variable containing the path would:

					- Still contain the characters which were accrued on the way down to that leaf node.
					- Continue to accumulate/append characters that existed from wherever execution went to next.
					- Not remove the characters that were accrued on the way to the leaf.

				3. Overall the variable containing the path would just continue to append the paths to each leaf growing ever longer.
				4. Only via recursion can those characers be removed as execution moves back up the tree, whereby keeping the path variable accurate.

				If Path Tracking must be done using iteration then need to do the following:

					1. Store the parent node in each node via the Constructor.
					2. Once at leaf node.
					3. Call a method which iteratively goes back up to root node while storing the value of each node that it traverses e.g. within a StringBuilder.
					4. Once reach the root (typically by testing for null)
					5. Reverse the String e.g. via StringBuilder.reverse.
					6. Print.

					void printPath(Node nLeaf)
					{
						Node n = nLeaf
        					StringBuilder sbWord = new StringBuilder();
        
        					while(n.getValue() != null)	//i.e. the null value within the null parent of nRoot
        					{
            						sbWord.append(n.getValue());
            						n = n.getParent();
        					}
        
        					System.out.println(sbWord.reverse());
					}

				However this is of course highly inefficient given the need to traverse back up the tree each time a leaf is found.

		Level Tracking:

			- Level tracking of the current height of the call stack (or depth into the call tree):

				void rc(input, iLevel)
				{
					if(baseCase == input)
						return

					for(i = 0 -> n)
						rc(modifiedInput_i, iLevel+1)

					postProcessing
				}

				Above iLevel will always be correct when within its respective recursive call, opposed to attempting to manage the increment/decrement an external variable to keep track.

		Dynamic Programming Questions:

			- Items to identify and consider in dynamic programming questions:

				Initial Input:		What is the initial input?

				Mutators:		What are the mutators that need to be continually applied to the input?

				Cases:			What are the base cases?
							What are the invalid cases?
							What are the ongoing cases?
							How many base cases need to be found: 1 | Some | All?

				Level:			Does the level/depth of recusion need to be known?

				Path:			Does a list of the mutations applied to reach the base case need to be known?

				Return Type:		Does the rm() need to return a value?

				Internal/External:	Does the input need to be passed down through the call tree or can be referenced via a variable declared external to rm()?

			- Typical Questions:

				- Does the problem only have x1 base/invalid case?
				- Does the base case exist?
				- Does the initial input form a combination of the mutator elements?
				- Process/mutate an external data structure?

			- General Approach:

				- Given that there does not appear to be any fixed standard architecture to recursive methods (as with all methods it is possible to implement functionality in multiple ways using multiple entities).
				- It may simply be a case of the following:

					1. Parameters:			Identify your relevant parameters

										Initial Input -> Base Case

											1. Additive:		0/Empty 	-> 	Target Value
											2. Subtractive:		Target Value	->	0/Empty

										Invalid Case
										Ongoing Case

										Result Set:

											1. Nodes/Inputs?
											2. Base Case Paths?

					2. Call Tree:			Draw out your call tree - if in doubt draw it out.
					3. Source Code:			Simply by refering to the call tree get your code to generate/reproduce your call tree by any means suitable.
					4. Techniques:			Learn those techniques for understanding how to reproduce your call tree.
					5. Optimisation Techniques:

						Memoisation:		Can any aspects of the overall calculation be stored/retrieved from within a hashmap rather than repeat identical calculation. 
						Removal:		Can any values be removed during the calculation process?
						Ignored:		Can any values be ignored during the calculation process?

		Memoisation

			Overview:

				- Memoisation is typically utilised during recursive method calls.
				- Memoisation is where the result of repeated input calculations are stored/retrieved (rather than repeatedly calculate the same input).
				- Memoisation typically involve the utilisation of a O(1) lookup table e.g. hashmap.

			Typicaly Approach:

				Call Tree:

					- To gain an understanding of where memoisation can be used.
					- Create a call tree which illustrates how many times a recursive method is called and which arguments are passed.
					- Given the below call tree, find the fib(7):

						      	      fib(7)
						 _______________|_______________
						|				|
						fib(5)				fib(6)
						|_______			|_______
						|	|			|	|
						fib(3)	fib(4)			fib(4)	fib(5)
						|	|			|	|


					- It becomes apparent that fib() gets called and passed the same argument many times.

				Hash Table:

					- Therefore store the values of all outputs of fib() as they are calculated.
					- Whereby:

						If fib(x) has already been calculated:		Get value from hashtable.
						If fib(x) has not already been calculated:	Calculate value and store in hashtable.

				Paradigm:

					- Each node should store its own result of the overall question being asked.
					- So that any other node of the same value does not need to be re-calculated and can be pull out of memo object.

						Original Input Value
						|_______________________________________________________________
						|				|				|
						Calculated Input Value 1	Calculated Input Value 2	Calculated Input Value 3
						|				|				|

					- Therefore if the question being asked:

						"What is the shortest path"				Each node should store the shortest path for that particular input value.
						"What is the number of unique combinations" 		Each node should store the number of unique combination for that particular input value.

					- The result is passed back up the tree to root to form the result using the original input value.
					- Memoisation can only begin once a node contains only base case and its calculated value forms the initial entries in the memo hashtable.
					- Components:

						Question:		The original question being asked and purpose of recursion/memoisation.
									The return type of the question maybe a boolean, integer or any other data type, each node must return the same data type.

						Original Input:		The value that is originally supplied by the external program, it is the ultimate result that is required.

						Node:			The intermediate or sub-input values to the recursive method calls.

						Base Case:		The node is valid and its path from top root node satifies the original question.
									The node will always be a leaf node.
									The total number of base cases will always = Size of any results that need to be fully calculated (all other nodes are calculated after the base cases by extract the pre-calculate values from the memo hashtable).
									The base cases form the foundation of the memo hashtable and recalled when building the paths of the higher values when being entered into the memo hashtable.

						Invalid Case:		Node is invalid and path is invalid and does not satifies the original question.

						Ongoing Case:		Node is valid and path is still valid but does not satisfy the original question, more recursive branching required to reach base or invalid case.

			Steps:

				Given a particular problem:

					1. Breakdown the larger problem into a series of smaller repeated/identical problems.
					2. Find the base case:

						Base Case:	The smallest case where no further recursive call is required.
						Conditional:	The base case would be checked at the start of the recursive function and return a constant value.
						Tree Leaves:	The base case would be considered the 'leaves' of the generated call tree.

					3. Once the base case is known, visualise the issue as a call tree.
					4. Each 'edge' of the call tree should decrease the size of the problem.
					5. Implement the call tree using recursion (trees are highly applicable to recursive/dynamic programming).
					6. Once working this would form the 'bute force' or 'naive' solution.

				Efficency:

					7. Increase efficency by introducing memoisation, whereby storing results and recalling if that particular calculation has already been done before.

			Base/Trival/Smallest Case:

				- Base case and the need to identify the base case is common to all dynamic programming problems.
				- Base case is typically dependent on the expected return type of the question:

					Return Type:		Base Case
					__________________________________

					int			0
					String			""
					Boolean			F
					Array			[] (Empty Array)

				- Base case is typically the 'smallest', 'largest' possible input or an input which satifies a particular criterion, whose result is self-evident or axiomatic.
				- Base case result is used to ultimately build up the results to the question being asked.

			Methodology:

				- Dynamic programming has x2 approaches:

					1. Recursive:		Utilising memoisation.
					2. Iteratively:		Utilising tabulation.

		Tabulation

			Overview:

				- Tabulation involves tabulating all of the intermediary results before arriving at the ultimate answer.
				- Tabulation is the most efficent means of computation opposed to recursion and memoisation.

			Components:

				- Question:		The question being asked or solution that needs to be found.
				- Target:		The original input value of the question.
				- Base Case:		The axiomatic base case which is the smallest input value for the question. It forms the starting point for the iterative population of the table towards reaching the answer to the target input value.
				- Table:		The table which holds all of the intermediary calculated values towards calculating the solution of target input value:
			
								Dimensions:	Number of inputs of target.
								Size/Range:	(0 - Target value dimension(s)).
								Data Type:	Each element contains the data type expected to be returned by the question if the process was 'started' from that element, each element is initialised to the default value of that type.

				- Iterative Logic:	The 'difficult bit' is working out the iterative logic in order to build up to the calculation of the target input value.

			Process:

				1. Table:		Build table.
				2. Base Case:		Define base cases.
				3. Iterative Logic:	Define iterative logic (typically by working with a relatively small target value to identify the necessary logic).
				4. Iteration:		Run the iteration up to the target input value.

			Example:

				1. Table:	Interpret the problem as a table, for exmaple:

							Fibonnaci:		Naturally would be a table of: 		1 Row 	n Col
							Grid Traveller:		Naturally would be a table of: 		m Row 	n Col

				2. Table Size:	The dimensions and size corresponds as follows:

							Table Dimensions:	Number of inputs as defined within the problem.
							Table Size/Range:	0 - Desired Target Value	 (it is necessary to calculate the intermediary values from 0 up to the desired target value)

						Depiction:

							canSum(7, [5, 3, 4]):

								  0   1	  2   3	  4   5	  6   7
								|   |	|   |	|   |	|   |	|

								Table Dimensions:	Number of inputs:			1
								Table Size/Range:	(0 - Desired Target Value):		7

							gridTraveller(3, 6)
								 _ _ _ _ _ _
 								|_|_|_|_|_|_|
 								|_|_|_|_|_|_|
 								|_|_|_|_|_|_|

								Table Dimensions:	Number of inputs:			2
								Table Size/Range:	(0 - Desired Target Value):		3 and 6
 
						NB: When declaring the table, given arrays are 0-based, it may be more worthwhile to declare [Size+1] so that can ignore the 0th element and use the 1-Size elements.

				3. Data Type:	Table elements should be of the same data type as the required answer to question.

				4. Initialise:	Initialise the table to any default values if necessary e.g. to all 0's or false.		

				5. Base Cases:	Define the base case, seed, smallest cases or smallest input values of the problem and the corresponding axiomatic answers, which may involve:

							1. Smallest Case:	Start with the smallest case e.g. element 0, element 1 or 1,1.
							2. Axiomatic Value:	Manually workout the answer for this case, typically this maybe an axiomatic value.
							3. Starting Point:	Use base cases as a starting point for building up the values in the remaining elements.
							4. Iterate:		Shift through all elements until reach the desired input target value.

				6. Iterative Logic:

						- Deriving the iterative logic is the most 'difficult aspect' of the overall implementation of tabulation.
						- This needs to derived on an adhoc basis, there is no predefined approach to deriving the logic given the question.
						- The best approach combines a number of aspects:

							1. Consider the nature of the problem.
							2. How is the target result derived, maybe work 'backwards'.
							3. Produce a small table/range and manually attempt to workout the logic.
							4. Build up say the first 0-10 elements to have confidence that the logic has been found.
							5. Apply the solution to all of the elements in the initial 0-10 test table to attempt to find the iterative process.

		Greedy Algorithm:

			- Greedy algorithm is a simple intuitive algorithm used in optimisation problems.
			- Greedy algorithm makes the optimal choice at each recursive stage with the data it has and is currently visible/available as it attempts to find the optimal solution of the overall problem.
			- Greedy algorithm is not suitable for all problems e.g. 'finding the largest sum':

						7
					________|_________
					3		12
				    ____|___	     ___|____
				    99	   8	     5	    6

				1. The traversed nodes will be:

					7, 12, 6 = 25

				2. The algorithm will overlook/not see the 99 from the the initial stage/root.

			- Greedy algorithm is more suitable for:

				Huffman Encoding
				Dijkstra Algorithm

			- Greedy algorithm is suitable for problems which adhere to the following x2 properties

				1. Greedy Choice: 		A global (overall) optimal solution can be reached by choosing the optimal choice at each stage of recursion/iteration.
				2. Optimal Substructure: 	A problem has an optimal substructure if an optimal solution to the entire problem contains the optimal solutions to the sub-problems.
									i.e. that the optimal solutions of all of the sub-problems constitute the optimal solution of the overall problem.

	Graph Traversal:

		Existing Graph/Structure

			- Yes
			- Graph is traversed using:

				DFS/BFS (utilising optional 'Visited' flag)
		Nodes:

			- Nodes are physical constructs in memory.
			- Nodes hold a value which can be mutated.

		Graph Types:

			- Graph
			- Tree
			- Binary Tree
				preOrder:	DFS
				inOrder:	Ascending order if Binary Search Tree
				postOrder
				levelOrder:	BFS

		Traversal:

			Graph:

				- BFS/DFS can be implemented recursively or iteratively:

					Recursive:

						B/DFT(Node n)
						{
							process n

							for(i -> n.children)
								stack/queue.add(n.child[i])

							while(!stack/queue.isEmpty())
								B/DFT(stack/queue.pop()/poll())
						}

					Iterative:

						B/DFT(Node nStart)
						{
							stack/queue.add(nStart)

							while(!stack/queue.isEmpty())
							{
								n = B/DFT(stack/queue.pop()/poll())

								process n

								for(i -> n.children)
									stack/queue.add(n.child[i])
							}
						}

				- BFS/DFS are identical expect that:

					Traversal		Datastructure
					_____________________________________

					Breadth			Queue	 
					Depth			Stack

				- BFS/DFS as defined above can be applied to all graphs:

					1. Graphs
					2. Tree
					3. Binary Tree

				- BFS/DFS can be used inconjunction with each node being an object containing a bVisited flag to prevent cycles. 

			Tree/Binary Tree:

				- Trees implement x4 sequences of traversal:

					1. preOrder:		Effectively DFT
					2. inOrder:		Binary Tree Only: Return ascending order if Binary Search Tree
					3. postOrder
					4. levelOrder:		Use general graph BFT

				- Trees can use the general graph algorithms for implementing DFT/BFT as shown above, however should the number of child nodes be fixed then the following can be used: 
				
							a
						_________________
						b		c
					_________________ _______________
					d		e f		g

					1. PreOrder:

						void preOrder(Node n)
						{
							if node == null
								return

							process n

							preOrder(node.child1)
							preOrder(node.child2)
							...
							preOrder(node.childn)
						}

						Traversal: a b d e c f g

					2. InOrder:

						void inOrder(Node n)
						{
							if node == null
								return

							inOrder(node.child1)
							process n
							inOrder(node.child2)
						}

						Traversal: d b e a f c g

					3. PostOrder:

						void postOrder(Node n)
						{
							if node == null
								return

							postOrder(node.child1)
							postOrder(node.child2)
							...
							postOrder(node.childn)

							process n
						}

						Traversal: d e b f g c a

					4. Level Order:

						Use the general graph BFT algorithm above.
	
		Techniques:

			- Windows Files Traversal:

				function void traverseAndProcess(Node n)
				{
					for(i = 0 to n.numberOfChildren)
					{
						check/process(n.child[i])

						if(n.child[i] == parent)
							traverseAndProcess(parent.child[i])
					}
				}

				- The above will traverse all nodes as follows:

					root
                    			1
                    			2
                    			3
                    			4 - Parent
                    			9   5
                    			10  6
                    			11  7
                    			12  8
                    			13
                    			14 - Parent
                    			18  15
                    			19  16
                        		    17

			- Tree Search (using a boolean):

				function void search(Node n, int iTarget)
				{
					if(n == null)
						return;

					if(n.value == iTarget)
					{
						bfound 		= true
						nTargetNode 	= node
					}
					else
					{
						for(i -> n.children && !bFound)
							search(node.child[i], n.value);
					}
				}

				function boolean search(Node n, int iTarget)
				{
					bFound1 = isTargetCriteria1Found(n, iTarget);
					bFound2 = isTargetCriteria2Found(n, iTarget);

					if(bFound1 && bFound2)
						return;

					for(i -> n.children.isValid() && !bFound1 && !bFound2)
						search(node.child[i], iTarget);

					return (bFound1 && bFound2);
				}

		Problems:

			- Path Finding:		Does a valid path exist between x2 nodes.
			- Path Finding:		Does a valid sequence of nodes exist in the graph e.g. word search.
			- Path Mutation:	Mutate the nodes on the path between root and destination.
			
	Backtracking:

		- Backtracking is a technique for finding solution(s) within a wider environment:

			1. DFS combined with either:

				2. Validation:

					- Validation involves systematically trying to 'feel its way' in trying to find an overall solution
					- Validation involves proceeding down to the a child node only if the input that would be passed to that child node is valid in working towards the overall solution.

				3. No Validation:

					- No validation simply tries all possible routes in trying to find the overall solution.
					- No validation involves proceeding down to the a child node only at all times, explore all child nodes and the whole tree.

		- Backtracking is a technique that is applied to any stateful environment:

			Elements:		Environment consists of a number of individual elements 			e.g. elements in array/grid/string/path (within another environment).
			Elements State:		Environment elements can each take on a range of values 			e.g. 0-9, a-z
			Environment:		Environment is the entity that is constituted by the elements 			e.g. array/grid/string
			Environment State:	Environment overall state is defined by the combination of the element states 	e.g. a 3-digit value is as follows:


							000
							001
							...
							099
							100
							101
							102

							- Environment can take on 1000 states (000 - 999).
							- Environment contains x3 elements which can each take on a state/value of 0-9.
							- Altering the individual elements alters the overall environment state.

		- Backtracking is a brute force technique for finding the correct overall environment state:

			Environment	Element:		Target Environment State (Base Case)
			_________________________________________________________________________________________________

			1D Array:	Element			Find a particular sequence of values which satisfy a criteria.
			2D Array:	Coordinate		Find a particular grid of values which satisfy a criteria.
			String:		Character		Find a particular sequence of characters which satisfy a criteria.
			Path:		Coordinate/Node		Find a particular path through another 2D array or graph which satisfy a criteria.

			Path may be the following:

				1D Array:		1D array which contains the individual coordinates/elements/information of a valid path through the environment e.g. 2D array or graph.
				Environment State:	Environment is being continually mutated until it contains a valid path (i.e. state).

			Validity check may be the following:

				Immediate Vicinity:	The immediate elements are checked as to whether they work toward the overall solution e.g. path finding
				Global:			All elements are checked as to whether they work toward the overall solution e.g. soduku solver

			Backtracking may appear inefficient but is normally the most and only way to solve a dynamic programming problem.

		- Backtracking can be implemented via a standard form with standard functional components/terms:

			findCompleteSolution(environment e, element eCurrent)
			{
	    			if(isSolutionComplete(e))					//Base Case == Path Found (Input/environment is in completed target state which represented the overall solution)
					process/add/copy environment to results
					return

				eNext = findNextElement(eCurrent)

	    	    	    	for(Value i = (mutator[0] -> mutator.n))			//Iterate through all of the possible ways forward from this particular environment state
	    	    	    	{
					if(isModificationValid(eNext, i))			//Check if the environment were to be modified by the ith mutator that it would be a valid way forward.
					{
						//Apply modification i:				//Apply modification to the environment by setting element eNext to i

						findCompleteSolution(modified_Environment[i], eNext);

						//Unapply the modification i			//Unapply the modification to the environment by removing i from element eNext
					}
	    	    	    	}
			}

			Environment:

				- Environment is the input to the problem.
				- Environment is mutated until the base case is found.

			Base Case:

				- Base case is when the environment state meets a specific target combination or criteria (typically the overall question being asked).
				- Base case should be tested at the top of each recursive call as with all recursive structures.
				- Backtracking contains only one base case which is the overall solution, there may be more than x1 overall solutions to the problem but backtracking is normally used to find and return the first.

			Invalid Case:

				- Invalid case is when all mutators have been tried and none of them are valid.
				- Invalid case is necessary to go back to the previous recursive call (i.e. previous element/state) and try further values in the range of values of the previous mutator.
				- Invalid case allows execution to go back to the previous element or parent node to hopefully find another valid value which is the correct path leading to the base case.

			Node:

				- Node represents an element or a particular environment state.
				- Node represents a particular recursive call on the call stack.


					Recursive Call n	Node n 	(Final Valid Element n)		Base Case (Complete solution found)
					...
					Recursive Call 3	Node 3	(Valid Element 3) 		Environment State 3
					Recursive Call 2	Node 2	(Valid Element 2) 		Environment State 2
					Recursive Call 1	Node 1	(Valid Element 1) 		Environment State 1
					Recursive Call 0	Root	(Valid Element for root) 	Environment State 0
					|______________|
						|
					   Call Stack

					- Recursive call 2 is the parent node of recursive call 3
			Mutator:

				- Mutator is the range of values/mutations that can be applied to individual elements or environment e.g. 0-9 or a-z.
				- Mutator is applied to each element 'pre-emptively'.
				- Mutator is applied to each element to check if it would be valid before proceeding onto the next element.

			Recursion (Ongoing):

				- Recursion is only performed should a valid value i or valid mutation be found for the next element.
				- Recursion is only performed should i work towards and not break the overall target environment criteria.

		- Backtracking involves:

			1. Look Ahead:		Pre-emptively 'looking ahead' to the next element.
			2. Propose Value:	'Trying' a particular range/sequence of proposed values.
			3. Valid:		If one of the proposed values would be valid in working toward the base case then move onto that element.
			4. Invalid:		If none of the proposed values yield a valid movement towards the base case then that means we a reached a 'dead end' and time to revert/backtrack to the previous/parent element/node.
			5. Further Values:	Within the parent node/recursive call continue trying all of the remaining potential values.
			6. Base Case:		If another value is found to be valid continue down that path hopefully reaching the base case.  

		- Backtracking 'Pre-emptive validation':

			With Pre-emptive Validation

				Base Cases:

					- Find x1 base case, x1 solution, x1 environment state which satisfies a criteria that needs to be applied to the whole environment.
					- Find more than x1 base case may also be applicable if the problem requires finding multple enivronment states which satisfy the criteria.

				Environmental Referencing:

					- Computation continually refers/checks progress against the wider criteria that needs to be found for the environment.
					- Computation requires checking/ensuring that the next 'step'/node/element is always valid, that the input to the next recursive call is always valid.
					- Computation determines that if there are no further valid 'steps' and it has reached the end of a branch in which needs to retrace back up (backtrack) the tree and try going down another branch that has not yet been explored.

				Path:

					- Computation tries to 'feel its way in the dark' by accessing all of the available options to stay on the 'right path' that would yield a complete solution.
					- Computation constricts the path of execution to only those nodes which would ultimately yield a complete solution.
					- Computation will only traverse a partial amount of the possible call tree i.e. those paths which end up yeilding the first complete solution.

				Mutators:

					- Mutators are not all valid and discarded accordingly.
					- Mutators are all sequentially pre-emptively assessed and validated at each node before entering the next node.
					- Mutators are checked to confirm if they adhere to the overall criteria and would reach a complete solution.

				Call Tree:

					- Call tree is only partially traversed.
					- Call tree is only traversed/reproduced down paths which may potentially lead to a complete solution.
					- Call tree may stop at a particular node if that node has no valid mutators, at which point execution retraces/backtracks up the current branch to try and find another potential branch.

			Without Pre-emptive Validation

				Base Cases:

					- Find x1, n or all base cases that are possible.

				Environmental Referencing:

					- Computation 'does not care' about the wider environment state.

				Path:

					- Computation does not try to cautiously try to 'feel its way in the dark' by accessing all of the available options to stay on the 'right path' that would yield a complete solution.
					- Computation simply tries all paths hoping to find a single/multiple/all base cases.

				Mutators:

					- Mutators are all considered valid.
					- Mutators are all applied at each node.

				Call Tree:

					- Call tree is fully traversed.
					- Call tree is fully reproduced all possible paths are traced.

		- Backtracking with:

			1D Array


			2D Array/Grid

				   0  1  2  3  4  5  6  7  8
				0 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				1 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				2 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				3 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				4 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				5 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				6 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				7 [ ][ ][ ][ ][ ][ ][ ][ ][ ]
				8 [ ][ ][ ][ ][ ][ ][ ][ ][ ]

				Problem:

					Please fill/complete board in accordance with a criterion.

				Standard Approach:

					1. Start at [0,0]
					2. Move from left-right, top-bottom.
					3. Pre-emptively check which of the available mutator values m1...mn would be valid move forward.
					4. If a mutator values is valid i.e. maintains the necessary criterion then move onto the next square/node.
					5. Continue until all of the squares have been completed and 

				Each square represents a node:

					     	     [ ]
					 _____________|_________
					|	|	|	|
					[m1]	[m2]	[m3]	[m4]
					|_____________________
							      |
							    [0,0]
						 _____________|_________
						|	|	|	|
						[m1]	[m2]	[m3]	[m4]
								|
							      [0,1]
							 _______|_______________
							|	|	|	|
							[m1]	[m2]	[m3]	[m4]
										|
									      [0,2]
							 		 _______|_______________
									|	|	|	|
									[m1]	[m2]	[m3]	[m4]
									|
									...

		- Backtracking can be used for:

			1. Find Paths:			Find all paths in the call tree which produce a base case?
			2. Find Number of Paths		Find total number of paths which produce a base case?

		- Backtracking involves unique inputs that are passed into each recursive call therefore memoisation may not always be appropriate/applicable.

		- Backtracking has the following general form:

			No Pre-Emptive Validation:

				Call Tree:

										       (input0)
				    		    _______________________________________|_______________________________________
				  		   |					   |					   |
				   		   | e0					   | e1					   | e2
				   		   |					   |					   |
			   		   (input1) = (i0*e0)		   	   (input2) = (i0*e1)		     	   (input3) = (i0*e2)
			    		    _______|_______			    _______|_______			    _______|_______
			   		   |	   |	   |			   |	   |	   |			   |	   |	   |
					(i1*e0)	(i1*e1)	(i1*e2)			(i2*e0)	(i2*e1)	(i2*e2)			(i3*e0)	(i3*e1)	(i3*e2)	

				Source Code:

					rm(input)
					{
	    	    	    			if(input == base case)					//Base case
							process
							return

	    	    	    			for(i -> mutator.n)
	    	    	    			{
							alPath.add(i)
							rm(modifiedInput[i])
							alPath.remove(i)
	    	    	    			}
					}

			Pre-Emptive Validation:

				Source Code:

					rm(input)
					{
	    	    	    			if(input == base case)					//Base case
							process
							return

	    	    	    			for(i -> mutator.n)
	    	    	    			{
							if(modifiedInput[i]/environment[i] == valid)	//Check ahead for valid case
							{
								alPath.add(i)
								rm(modifiedInput[i]/environment[i])
								alPath.remove(i)
							}
	    	    	    			}
					}

			Call Tree:

				- Assess the overall question being asked and draw out the corresponding call tree that would successfully find the necessary base cases.

			Initial Input/State:

				- Initial input or environment state (Input0) is explicitly defined within the initial rm(Input0) call within the initial method.

			Mutator:

				- Mutator is the range/collection of mutation elements [e0, e1, e2 ...] that can be applied to the initial and recursive inputs.
				- Mutator may not necessarily be an array but is a representation of the range/collection of mutations/options that can be applied to the initial and recursive inputs. 

			Path Legs:

				- Path legs represent a valid mutation of the parent rm() calls input.
				- Path legs values represent the individual mutator elements which generate valid subsequent rm() calls.

			Nodes:

				- Nodes represent the 'existence' of a valid rm() call.
				- Nodes value is the particular input/state which was passed to that instance of rm(input) call e.g. (i0*e0) input is the result of input0 being mutated by mutator element 0.
				- Nodes signify that the particular input/state for that rm(input) is a valid mutation of the input/state in the previous rm() call.
				
			Check Ahead:

				- Nodes are checked for validity by 'checking ahead' before making and entering a subsequent rm() rather than check once within the rm() and return.

			Path:

				- Path will consist of the individual combinations of mutator elements which will combine and reach the base cases.
				- Path is built up and stored within the List<Mutator_Element> ArrayList<>();
					


	Reading Recursive Methods:

		How to read recursive methods include the following:

			1. rm calls():				Where are the rm() calls?
			2. return:				Where are the return points?

									Explicit:	Manual [recursive return]
									Natural:	End of function

			3. return type/values:			What are the possible values that can be returned?
			4. Standard Structural Elements:	If possible attempt to identify the standard structrual elements as defined above (for the actual source code may be of a differing structure).



















